[
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "plasTeX.Base",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plasTeX.Base",
        "description": "plasTeX.Base",
        "detail": "plasTeX.Base",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "Card",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "Deck",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "Hand",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "Deck",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "Hand",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "Deck",
        "importPath": "Card",
        "description": "Card",
        "isExtraImport": true,
        "detail": "Card",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "print_point",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "Point1",
        "description": "Point1",
        "isExtraImport": true,
        "detail": "Point1",
        "documentation": {}
    },
    {
        "label": "distance_between_points",
        "importPath": "Point1_soln",
        "description": "Point1_soln",
        "isExtraImport": true,
        "detail": "Point1_soln",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "Time1",
        "description": "Time1",
        "isExtraImport": true,
        "detail": "Time1",
        "documentation": {}
    },
    {
        "label": "shelve",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shelve",
        "description": "shelve",
        "detail": "shelve",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "anagram_sets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "anagram_sets",
        "description": "anagram_sets",
        "detail": "anagram_sets",
        "documentation": {}
    },
    {
        "label": "all_anagrams",
        "importPath": "anagram_sets",
        "description": "anagram_sets",
        "isExtraImport": true,
        "detail": "anagram_sets",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "anagram_sets",
        "description": "anagram_sets",
        "isExtraImport": true,
        "detail": "anagram_sets",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "process_file",
        "importPath": "analyze_book1",
        "description": "analyze_book1",
        "isExtraImport": true,
        "detail": "analyze_book1",
        "documentation": {}
    },
    {
        "label": "process_file",
        "importPath": "analyze_book1",
        "description": "analyze_book1",
        "isExtraImport": true,
        "detail": "analyze_book1",
        "documentation": {}
    },
    {
        "label": "process_file",
        "importPath": "analyze_book1",
        "description": "analyze_book1",
        "isExtraImport": true,
        "detail": "analyze_book1",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "bisect",
        "importPath": "bisect",
        "description": "bisect",
        "isExtraImport": true,
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "turtle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "turtle",
        "description": "turtle",
        "detail": "turtle",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "Circle",
        "description": "Circle",
        "isExtraImport": true,
        "detail": "Circle",
        "documentation": {}
    },
    {
        "label": "polygon",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "polygon",
        "description": "polygon",
        "detail": "polygon",
        "documentation": {}
    },
    {
        "label": "arc",
        "importPath": "polygon",
        "description": "polygon",
        "isExtraImport": true,
        "detail": "polygon",
        "documentation": {}
    },
    {
        "label": "circle",
        "importPath": "polygon",
        "description": "polygon",
        "isExtraImport": true,
        "detail": "polygon",
        "documentation": {}
    },
    {
        "label": "arc",
        "importPath": "polygon",
        "description": "polygon",
        "isExtraImport": true,
        "detail": "polygon",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "read_dictionary",
        "importPath": "pronounce",
        "description": "pronounce",
        "isExtraImport": true,
        "detail": "pronounce",
        "documentation": {}
    },
    {
        "label": "make_word_list",
        "importPath": "inlist",
        "description": "inlist",
        "isExtraImport": true,
        "detail": "inlist",
        "documentation": {}
    },
    {
        "label": "in_bisect",
        "importPath": "inlist",
        "description": "inlist",
        "isExtraImport": true,
        "detail": "inlist",
        "documentation": {}
    },
    {
        "label": "in_bisect",
        "importPath": "inlist",
        "description": "inlist",
        "isExtraImport": true,
        "detail": "inlist",
        "documentation": {}
    },
    {
        "label": "make_word_list",
        "importPath": "inlist",
        "description": "inlist",
        "isExtraImport": true,
        "detail": "inlist",
        "documentation": {}
    },
    {
        "label": "skip_gutenberg_header",
        "importPath": "markov",
        "description": "markov",
        "isExtraImport": true,
        "detail": "markov",
        "documentation": {}
    },
    {
        "label": "shift",
        "importPath": "markov",
        "description": "markov",
        "isExtraImport": true,
        "detail": "markov",
        "documentation": {}
    },
    {
        "label": "rotate_word",
        "importPath": "rotate",
        "description": "rotate",
        "isExtraImport": true,
        "detail": "rotate",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "book.figs.loop",
        "description": "book.figs.loop",
        "peekOfCode": "def pipe(cmd):\n    fp = os.popen(cmd)\n    res = fp.read()\n    stat = fp.close()\n    return res, stat\ndef main(script, files='*.eps'):\n    for filename in sorted(glob(files)):\n        destination = '.'.join(filename.split('.')[:-1]) + '.pdf'\n        cmd = 'convert %s %s' % (filename, destination) \n        print cmd",
        "detail": "book.figs.loop",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "book.figs.loop",
        "description": "book.figs.loop",
        "peekOfCode": "def main(script, files='*.eps'):\n    for filename in sorted(glob(files)):\n        destination = '.'.join(filename.split('.')[:-1]) + '.pdf'\n        cmd = 'convert %s %s' % (filename, destination) \n        print cmd\n        res, stat = pipe(cmd)\n        print res, stat\nif __name__ == '__main__':\n    main(*sys.argv)",
        "detail": "book.figs.loop",
        "documentation": {}
    },
    {
        "label": "Eqn",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class Eqn(Base.Command):\n    args = 'self'\nclass Anchor(Base.Command):\n    args = 'label:str'\n    def invoke(self, tex):\n        Base.Command.invoke(self, tex)\n        self.ownerDocument.context.label(self.attributes['label'], self)\nclass exercise(Base.Environment):\n    counter = 'exercise'\nclass index(Base.Command):",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "Anchor",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class Anchor(Base.Command):\n    args = 'label:str'\n    def invoke(self, tex):\n        Base.Command.invoke(self, tex)\n        self.ownerDocument.context.label(self.attributes['label'], self)\nclass exercise(Base.Environment):\n    counter = 'exercise'\nclass index(Base.Command):\n    args = 'termstring'\n    def setEntry(self, s, seetype=0):",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "exercise",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class exercise(Base.Environment):\n    counter = 'exercise'\nclass index(Base.Command):\n    args = 'termstring'\n    def setEntry(self, s, seetype=0):\n    #    TYPE_NORMAL = 0\n    #    TYPE_SEE = 1\n    #    TYPE_SEEALSO = 2\n        if type(s) != type(''):\n            s = s.textContent",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class index(Base.Command):\n    args = 'termstring'\n    def setEntry(self, s, seetype=0):\n    #    TYPE_NORMAL = 0\n    #    TYPE_SEE = 1\n    #    TYPE_SEEALSO = 2\n        if type(s) != type(''):\n            s = s.textContent\n        if s.count('!'):\n            priterm, secterm = s.split('!')",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "scriptN",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class scriptN(Base.Command):\n       unicode = u'\\U0001D4A9'\nclass uxbar(Base.Command): pass\nclass uybar(Base.Command): pass\nclass unhat(Base.Command): pass\nclass ule(Base.Command): pass\nclass minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "uxbar",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class uxbar(Base.Command): pass\nclass uybar(Base.Command): pass\nclass unhat(Base.Command): pass\nclass ule(Base.Command): pass\nclass minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "uybar",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class uybar(Base.Command): pass\nclass unhat(Base.Command): pass\nclass ule(Base.Command): pass\nclass minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "unhat",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class unhat(Base.Command): pass\nclass ule(Base.Command): pass\nclass minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "ule",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class ule(Base.Command): pass\nclass minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "minus",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class minus(Base.Command): pass\nclass lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "lowast",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class lowast(Base.Command): pass\nclass Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "Erdos",
        "kind": 6,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "class Erdos(Base.Command): pass",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "idgen",
        "kind": 2,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "def idgen():\n    \"\"\" Generate a unique ID \"\"\"\n    i = 1\n    while 1:\n        yield 'a%.10d' % i\n        i += 1\nidgen = idgen()\nclass Eqn(Base.Command):\n    args = 'self'\nclass Anchor(Base.Command):",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "idgen",
        "kind": 5,
        "importPath": "book.localdef",
        "description": "book.localdef",
        "peekOfCode": "idgen = idgen()\nclass Eqn(Base.Command):\n    args = 'self'\nclass Anchor(Base.Command):\n    args = 'label:str'\n    def invoke(self, tex):\n        Base.Command.invoke(self, tex)\n        self.ownerDocument.context.label(self.attributes['label'], self)\nclass exercise(Base.Environment):\n    counter = 'exercise'",
        "detail": "book.localdef",
        "documentation": {}
    },
    {
        "label": "Kangaroo",
        "kind": 6,
        "importPath": "code.BadKangaroo",
        "description": "code.BadKangaroo",
        "peekOfCode": "class Kangaroo:\n    \"\"\"A Kangaroo is a marsupial.\"\"\"\n    # 在Python中，如果一个函数或方法的参数使用了一个可变对象（例如列表、字典等）作为默认值，\n    # 那么所有使用该默认值的对象都会共享一个对象。\n    def __init__(self, name, contents=None):\n        \"\"\"Initialize the pouch contents.\n        name: string\n        contents: initial pouch contents.\n        \"\"\"\n        self.name = name",
        "detail": "code.BadKangaroo",
        "documentation": {}
    },
    {
        "label": "kanga",
        "kind": 5,
        "importPath": "code.BadKangaroo",
        "description": "code.BadKangaroo",
        "peekOfCode": "kanga = Kangaroo('Kanga')\nroo = Kangaroo('Roo')\n# kanga.put_in_pouch('wallet')\n# kanga.put_in_pouch('car keys')\nkanga.put_in_pouch(roo)\nprint(kanga)\n# If you run this program as is, it seems to work.\n# To see the problem, trying printing roo.\n# Hint: to find the problem try running pylint.",
        "detail": "code.BadKangaroo",
        "documentation": {}
    },
    {
        "label": "roo",
        "kind": 5,
        "importPath": "code.BadKangaroo",
        "description": "code.BadKangaroo",
        "peekOfCode": "roo = Kangaroo('Roo')\n# kanga.put_in_pouch('wallet')\n# kanga.put_in_pouch('car keys')\nkanga.put_in_pouch(roo)\nprint(kanga)\n# If you run this program as is, it seems to work.\n# To see the problem, trying printing roo.\n# Hint: to find the problem try running pylint.",
        "detail": "code.BadKangaroo",
        "documentation": {}
    },
    {
        "label": "Card",
        "kind": 6,
        "importPath": "code.Card",
        "description": "code.Card",
        "peekOfCode": "class Card:\n    \"\"\"Represents a standard playing card.\n    Attributes:\n      suit: integer 0-3\n      rank: integer 1-13\n    \"\"\"\n    suit_names = [\"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\"]\n    rank_names = [None, \"Ace\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \n              \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\"]\n    def __init__(self, suit=0, rank=2):",
        "detail": "code.Card",
        "documentation": {}
    },
    {
        "label": "Deck",
        "kind": 6,
        "importPath": "code.Card",
        "description": "code.Card",
        "peekOfCode": "class Deck:\n    \"\"\"Represents a deck of cards.\n    Attributes:\n      cards: list of Card objects.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the Deck with 52 cards.\n        \"\"\"\n        self.cards = []\n        for suit in range(4):",
        "detail": "code.Card",
        "documentation": {}
    },
    {
        "label": "Hand",
        "kind": 6,
        "importPath": "code.Card",
        "description": "code.Card",
        "peekOfCode": "class Hand(Deck):\n    \"\"\"Represents a hand of playing cards.\"\"\"\n    def __init__(self, label=''):\n        self.cards = []\n        self.label = label\ndef find_defining_class(obj, method_name):\n    \"\"\"Finds and returns the class object that will provide \n    the definition of method_name (as a string) if it is\n    invoked on obj.\n    obj: any python object",
        "detail": "code.Card",
        "documentation": {}
    },
    {
        "label": "find_defining_class",
        "kind": 2,
        "importPath": "code.Card",
        "description": "code.Card",
        "peekOfCode": "def find_defining_class(obj, method_name):\n    \"\"\"Finds and returns the class object that will provide \n    the definition of method_name (as a string) if it is\n    invoked on obj.\n    obj: any python object\n    method_name: string method name\n    \"\"\"\n    for ty in type(obj).mro():\n        if method_name in ty.__dict__:\n            return ty",
        "detail": "code.Card",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "code.Card_test",
        "description": "code.Card_test",
        "peekOfCode": "class Test(unittest.TestCase):\n    def testDeckRemove(self):\n        deck = Deck()\n        card23 = Card(2, 3)\n        deck.remove_card(card23)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "code.Card_test",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "code.Circle",
        "description": "code.Circle",
        "peekOfCode": "class Circle:\n    \"\"\"Represents a circle.\n    Attributes: center, radius\n    \"\"\"\ndef point_in_circle(point, circle):\n    \"\"\"Checks whether a point lies inside a circle (or on the boundary).\n    point: Point object\n    circle: Circle object\n    \"\"\"\n    d = distance_between_points(point, circle.center)",
        "detail": "code.Circle",
        "documentation": {}
    },
    {
        "label": "point_in_circle",
        "kind": 2,
        "importPath": "code.Circle",
        "description": "code.Circle",
        "peekOfCode": "def point_in_circle(point, circle):\n    \"\"\"Checks whether a point lies inside a circle (or on the boundary).\n    point: Point object\n    circle: Circle object\n    \"\"\"\n    d = distance_between_points(point, circle.center)\n    print(d)\n    return d <= circle.radius\ndef rect_in_circle(rect, circle):\n    \"\"\"Checks whether the corners of a rect fall in/on a circle.",
        "detail": "code.Circle",
        "documentation": {}
    },
    {
        "label": "rect_in_circle",
        "kind": 2,
        "importPath": "code.Circle",
        "description": "code.Circle",
        "peekOfCode": "def rect_in_circle(rect, circle):\n    \"\"\"Checks whether the corners of a rect fall in/on a circle.\n    rect: Rectangle object\n    circle: Circle object\n    \"\"\"\n    p = copy.copy(rect.corner)\n    print_point(p)\n    if not point_in_circle(p, circle):\n        return False\n    p.x += rect.width",
        "detail": "code.Circle",
        "documentation": {}
    },
    {
        "label": "rect_circle_overlap",
        "kind": 2,
        "importPath": "code.Circle",
        "description": "code.Circle",
        "peekOfCode": "def rect_circle_overlap(rect, circle):\n    \"\"\"Checks whether any corners of a rect fall in/on a circle.\n    rect: Rectangle object\n    circle: Circle object\n    \"\"\"\n    p = copy.copy(rect.corner)\n    print_point(p)\n    if point_in_circle(p, circle):\n        return True\n    p.x += rect.width",
        "detail": "code.Circle",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Circle",
        "description": "code.Circle",
        "peekOfCode": "def main():\n    box = Rectangle()\n    box.width = 100.0\n    box.height = 200.0\n    box.corner = Point()\n    box.corner.x = 50.0\n    box.corner.y = 50.0\n    print(box.corner.x)\n    print(box.corner.y)\n    circle = Circle",
        "detail": "code.Circle",
        "documentation": {}
    },
    {
        "label": "Kangaroo",
        "kind": 6,
        "importPath": "code.GoodKangaroo",
        "description": "code.GoodKangaroo",
        "peekOfCode": "class Kangaroo:\n    \"\"\"A Kangaroo is a marsupial.\"\"\"\n    def __init__(self, name, contents=[]):\n        \"\"\"Initialize the pouch contents.\n        name: string\n        contents: initial pouch contents.\n        \"\"\"\n        # The problem is the default value for contents.\n        # Default values get evaluated ONCE, when the function\n        # is defined; they don't get evaluated again when the",
        "detail": "code.GoodKangaroo",
        "documentation": {}
    },
    {
        "label": "kanga",
        "kind": 5,
        "importPath": "code.GoodKangaroo",
        "description": "code.GoodKangaroo",
        "peekOfCode": "kanga = Kangaroo('Kanga')\nroo = Kangaroo('Roo')\nkanga.put_in_pouch('wallet')\nkanga.put_in_pouch('car keys')\nkanga.put_in_pouch(roo)\nprint(kanga)\nprint(roo)\n# If you run this program as is, it seems to work.\n# To see the problem, trying printing roo.",
        "detail": "code.GoodKangaroo",
        "documentation": {}
    },
    {
        "label": "roo",
        "kind": 5,
        "importPath": "code.GoodKangaroo",
        "description": "code.GoodKangaroo",
        "peekOfCode": "roo = Kangaroo('Roo')\nkanga.put_in_pouch('wallet')\nkanga.put_in_pouch('car keys')\nkanga.put_in_pouch(roo)\nprint(kanga)\nprint(roo)\n# If you run this program as is, it seems to work.\n# To see the problem, trying printing roo.",
        "detail": "code.GoodKangaroo",
        "documentation": {}
    },
    {
        "label": "LinearMap",
        "kind": 6,
        "importPath": "code.Map",
        "description": "code.Map",
        "peekOfCode": "class LinearMap:\n    \"\"\"A simple implementation of a map using a list of tuples\n    where each tuple is a key-value pair.\"\"\"\n    def __init__(self):\n        self.items = []\n    def add(self, k, v):\n        \"\"\"Adds a new item that maps from key (k) to value (v).\n        Assumes that they keys are unique.\"\"\"\n        self.items.append((k, v))\n    def get(self, k):",
        "detail": "code.Map",
        "documentation": {}
    },
    {
        "label": "BetterMap",
        "kind": 6,
        "importPath": "code.Map",
        "description": "code.Map",
        "peekOfCode": "class BetterMap:\n    \"\"\"A faster implementation of a map using a list of LinearMaps\n    and the built-in function hash() to determine which LinearMap\n    to put each key into.\"\"\"\n    def __init__(self, n=100):\n        \"\"\"Appends (n) LinearMaps onto (self).\"\"\"\n        self.maps = []\n        for i in range(n):\n            self.maps.append(LinearMap())\n    def find_map(self, k):",
        "detail": "code.Map",
        "documentation": {}
    },
    {
        "label": "HashMap",
        "kind": 6,
        "importPath": "code.Map",
        "description": "code.Map",
        "peekOfCode": "class HashMap:\n    \"\"\"An implementation of a hashtable using a BetterMap\n    that grows so that the number of items never exceeds the number\n    of LinearMaps.\n    The amortized cost of add should be O(1) provided that the\n    implementation of sum in resize is linear.\"\"\"\n    def __init__(self):\n        \"\"\"Starts with 2 LinearMaps and 0 items.\"\"\"\n        self.maps = BetterMap(2)\n        self.num = 0",
        "detail": "code.Map",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Map",
        "description": "code.Map",
        "peekOfCode": "def main():\n    import string\n    m = HashMap()\n    s = string.ascii_lowercase\n    for k, v in enumerate(s):\n        m.add(k, v)\n    for k in range(len(s)):\n        print(k, m.get(k))\nif __name__ == '__main__':\n    main()",
        "detail": "code.Map",
        "documentation": {}
    },
    {
        "label": "Point",
        "kind": 6,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "class Point:\n    \"\"\"Represents a point in 2-D space.\n    attributes: x, y\n    \"\"\"\ndef print_point(p):\n    \"\"\"Print a Point object in human-readable format.\"\"\"\n    print('(%g, %g)' % (p.x, p.y))\nclass Rectangle:\n    \"\"\"Represents a rectangle. \n    attributes: width, height, corner.",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "kind": 6,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "class Rectangle:\n    \"\"\"Represents a rectangle. \n    attributes: width, height, corner.\n    \"\"\"\ndef find_center(rect):\n    \"\"\"Returns a Point at the center of a Rectangle.\n    rect: Rectangle\n    returns: new Point\n    \"\"\"\n    p = Point()",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "print_point",
        "kind": 2,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "def print_point(p):\n    \"\"\"Print a Point object in human-readable format.\"\"\"\n    print('(%g, %g)' % (p.x, p.y))\nclass Rectangle:\n    \"\"\"Represents a rectangle. \n    attributes: width, height, corner.\n    \"\"\"\ndef find_center(rect):\n    \"\"\"Returns a Point at the center of a Rectangle.\n    rect: Rectangle",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "find_center",
        "kind": 2,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "def find_center(rect):\n    \"\"\"Returns a Point at the center of a Rectangle.\n    rect: Rectangle\n    returns: new Point\n    \"\"\"\n    p = Point()\n    p.x = rect.corner.x + rect.width/2.0\n    p.y = rect.corner.y + rect.height/2.0\n    return p\ndef grow_rectangle(rect, dwidth, dheight):",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "grow_rectangle",
        "kind": 2,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "def grow_rectangle(rect, dwidth, dheight):\n    \"\"\"Modifies the Rectangle by adding to its width and height.\n    rect: Rectangle object.\n    dwidth: change in width (can be negative).\n    dheight: change in height (can be negative).\n    \"\"\"\n    rect.width += dwidth\n    rect.height += dheight\ndef main():\n    blank = Point()",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Point1",
        "description": "code.Point1",
        "peekOfCode": "def main():\n    blank = Point()\n    blank.x = 3\n    blank.y = 4\n    print('blank', end=' ')\n    print_point(blank)\n    box = Rectangle()\n    box.width = 100.0\n    box.height = 200.0\n    box.corner = Point()",
        "detail": "code.Point1",
        "documentation": {}
    },
    {
        "label": "distance_between_points",
        "kind": 2,
        "importPath": "code.Point1_soln",
        "description": "code.Point1_soln",
        "peekOfCode": "def distance_between_points(p1, p2):\n    \"\"\"Computes the distance between two Point objects.\n    p1: Point\n    p2: Point\n    returns: float\n    \"\"\"\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dist = math.sqrt(dx**2 + dy**2)\n    return dist",
        "detail": "code.Point1_soln",
        "documentation": {}
    },
    {
        "label": "move_rectangle",
        "kind": 2,
        "importPath": "code.Point1_soln",
        "description": "code.Point1_soln",
        "peekOfCode": "def move_rectangle(rect, dx, dy):\n    \"\"\"Move the Rectangle by modifying its corner object.\n    rect: Rectangle object.\n    dx: change in x coordinate (can be negative).\n    dy: change in y coordinate (can be negative).\n    \"\"\"\n    rect.corner.x += dx\n    rect.corner.y += dy\ndef move_rectangle_copy(rect, dx, dy):\n    \"\"\"Move the Rectangle and return a new Rectangle object.",
        "detail": "code.Point1_soln",
        "documentation": {}
    },
    {
        "label": "move_rectangle_copy",
        "kind": 2,
        "importPath": "code.Point1_soln",
        "description": "code.Point1_soln",
        "peekOfCode": "def move_rectangle_copy(rect, dx, dy):\n    \"\"\"Move the Rectangle and return a new Rectangle object.\n    rect: Rectangle object.\n    dx: change in x coordinate (can be negative).\n    dy: change in y coordinate (can be negative).\n    returns: new Rectangle\n    \"\"\"\n    new = copy.deepcopy(rect)\n    move_rectangle(new, dx, dy)\n    return new",
        "detail": "code.Point1_soln",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Point1_soln",
        "description": "code.Point1_soln",
        "peekOfCode": "def main():\n    blank = Point()\n    blank.x = 0\n    blank.y = 0\n    grosse = Point()\n    grosse.x = 3\n    grosse.y = 4\n    print('distance', end=' ')\n    print(distance_between_points(grosse, blank))\n    box = Rectangle()",
        "detail": "code.Point1_soln",
        "documentation": {}
    },
    {
        "label": "Point",
        "kind": 6,
        "importPath": "code.Point2_soln",
        "description": "code.Point2_soln",
        "peekOfCode": "class Point:\n    \"\"\"Represents a point in 2-D space.\n    attributes: x, y\n    \"\"\"\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return '(%g, %g)' % (self.x, self.y)\n    def __add__(self, other):",
        "detail": "code.Point2_soln",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Point2_soln",
        "description": "code.Point2_soln",
        "peekOfCode": "def main():\n    p1 = Point(1, 2)\n    p2 = Point(3, 4)\n    print(p1)\n    print(p2)\n    print(p1 + p2)\n    print(p1 + (3, 4))\nif __name__ == '__main__':\n    main()",
        "detail": "code.Point2_soln",
        "documentation": {}
    },
    {
        "label": "PokerHand",
        "kind": 6,
        "importPath": "code.PokerHand",
        "description": "code.PokerHand",
        "peekOfCode": "class PokerHand(Hand):\n    \"\"\"Represents a poker hand.\"\"\"\n    def suit_hist(self):\n        \"\"\"Builds a histogram of the suits that appear in the hand.\n        Stores the result in attribute suits.\n        \"\"\"\n        self.suits = {}\n        for card in self.cards:\n            self.suits[card.suit] = self.suits.get(card.suit, 0) + 1\n    def has_flush(self):",
        "detail": "code.PokerHand",
        "documentation": {}
    },
    {
        "label": "Hist",
        "kind": 6,
        "importPath": "code.PokerHandSoln",
        "description": "code.PokerHandSoln",
        "peekOfCode": "class Hist(dict):\n    \"\"\"A map from each item (x) to its frequency.\"\"\"\n    def __init__(self, seq=[]):\n        \"Creates a new histogram starting with the items in seq.\"\n        for x in seq:\n            self.count(x)\n    def count(self, x, f=1):\n        \"Increments (or decrements) the counter associated with item x.\"\n        self[x] = self.get(x, 0) + f\n        if self[x] == 0:",
        "detail": "code.PokerHandSoln",
        "documentation": {}
    },
    {
        "label": "PokerHand",
        "kind": 6,
        "importPath": "code.PokerHandSoln",
        "description": "code.PokerHandSoln",
        "peekOfCode": "class PokerHand(Hand):\n    \"\"\"Represents a poker hand.\"\"\"\n    all_labels = ['straightflush', 'fourkind', 'fullhouse', 'flush',\n                  'straight', 'threekind', 'twopair', 'pair', 'highcard']\n    def make_histograms(self):\n        \"\"\"Computes histograms for suits and hands.\n        Creates attributes:\n          suits: a histogram of the suits in the hand.\n          ranks: a histogram of the ranks.\n          sets: a sorted list of the rank sets in the hand.",
        "detail": "code.PokerHandSoln",
        "documentation": {}
    },
    {
        "label": "PokerDeck",
        "kind": 6,
        "importPath": "code.PokerHandSoln",
        "description": "code.PokerHandSoln",
        "peekOfCode": "class PokerDeck(Deck):\n    \"\"\"Represents a deck of cards that can deal poker hands.\"\"\"\n    def deal_hands(self, num_cards=5, num_hands=10):\n        \"\"\"Deals hands from the deck and returns Hands.\n        num_cards: cards per hand\n        num_hands: number of hands\n        returns: list of Hands\n        \"\"\"\n        hands = []\n        for i in range(num_hands):        ",
        "detail": "code.PokerHandSoln",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.PokerHandSoln",
        "description": "code.PokerHandSoln",
        "peekOfCode": "def main():\n    # the label histogram: map from label to number of occurances\n    lhist = Hist()\n    # loop n times, dealing 7 hands per iteration, 7 cards each\n    n = 10000\n    for i in range(n):\n        if i % 1000 == 0:\n            print(i)\n        deck = PokerDeck()\n        deck.shuffle()",
        "detail": "code.PokerHandSoln",
        "documentation": {}
    },
    {
        "label": "Time",
        "kind": 6,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "class Time:\n    \"\"\"Represents the time of day.\n    attributes: hour, minute, second\n    \"\"\"\ndef print_time(t):\n    \"\"\"Prints a string representation of the time.\n    t: Time object\n    \"\"\"\n    print('%.2d:%.2d:%.2d' % (t.hour, t.minute, t.second))\ndef int_to_time(seconds):",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "print_time",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def print_time(t):\n    \"\"\"Prints a string representation of the time.\n    t: Time object\n    \"\"\"\n    print('%.2d:%.2d:%.2d' % (t.hour, t.minute, t.second))\ndef int_to_time(seconds):\n    \"\"\"Makes a new Time object.\n    seconds: int seconds since midnight.\n    \"\"\"\n    time = Time()",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "int_to_time",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def int_to_time(seconds):\n    \"\"\"Makes a new Time object.\n    seconds: int seconds since midnight.\n    \"\"\"\n    time = Time()\n    minutes, time.second = divmod(seconds, 60)\n    time.hour, time.minute = divmod(minutes, 60)\n    return time\ndef time_to_int(time):\n    \"\"\"Computes the number of seconds since midnight.",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "time_to_int",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def time_to_int(time):\n    \"\"\"Computes the number of seconds since midnight.\n    time: Time object.\n    \"\"\"\n    minutes = time.hour * 60 + time.minute\n    seconds = minutes * 60 + time.second\n    return seconds\ndef add_times(t1, t2):\n    \"\"\"Adds two time objects.\n    t1, t2: Time",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "add_times",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def add_times(t1, t2):\n    \"\"\"Adds two time objects.\n    t1, t2: Time\n    returns: Time\n    \"\"\"\n    assert valid_time(t1) and valid_time(t2)\n    seconds = time_to_int(t1) + time_to_int(t2)\n    return int_to_time(seconds)\ndef valid_time(time):\n    \"\"\"Checks whether a Time object satisfies the invariants.",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "valid_time",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def valid_time(time):\n    \"\"\"Checks whether a Time object satisfies the invariants.\n    time: Time\n    returns: boolean\n    \"\"\"\n    if time.hour < 0 or time.minute < 0 or time.second < 0:\n        return False\n    if time.minute >= 60 or time.second >= 60:\n        return False\n    return True",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Time1",
        "description": "code.Time1",
        "peekOfCode": "def main():\n    # if a movie starts at noon...\n    noon_time = Time()\n    noon_time.hour = 12\n    noon_time.minute = 0\n    noon_time.second = 0\n    print('Starts at', end=' ')\n    print_time(noon_time)\n    # and the run time of the movie is 109 minutes...\n    movie_minutes = 109",
        "detail": "code.Time1",
        "documentation": {}
    },
    {
        "label": "is_after",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def is_after(t1, t2):\n    \"\"\"Returns True if t1 is after t2; false otherwise.\"\"\"\n    return (t1.hour, t1.minute, t1.second) > (t2.hour, t2.minute, t2.second)\ndef increment(t1, seconds):\n    \"\"\"Adds seconds to a Time object.\"\"\"\n    assert valid_time(t1)\n    seconds += time_to_int(t1)\n    return int_to_time(seconds)\ndef mul_time(t1, factor):\n    \"\"\"Multiplies a Time object by a factor.\"\"\"",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "increment",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def increment(t1, seconds):\n    \"\"\"Adds seconds to a Time object.\"\"\"\n    assert valid_time(t1)\n    seconds += time_to_int(t1)\n    return int_to_time(seconds)\ndef mul_time(t1, factor):\n    \"\"\"Multiplies a Time object by a factor.\"\"\"\n    assert valid_time(t1)\n    seconds = time_to_int(t1) * factor\n    return int_to_time(seconds)",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "mul_time",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def mul_time(t1, factor):\n    \"\"\"Multiplies a Time object by a factor.\"\"\"\n    assert valid_time(t1)\n    seconds = time_to_int(t1) * factor\n    return int_to_time(seconds)\ndef days_until_birthday(birthday):\n    \"\"\"How long until my next birthday?\"\"\"\n    today = datetime.today()\n    # when is my birthday this year?\n    next_birthday = datetime(today.year, birthday.month, birthday.day)",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "days_until_birthday",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def days_until_birthday(birthday):\n    \"\"\"How long until my next birthday?\"\"\"\n    today = datetime.today()\n    # when is my birthday this year?\n    next_birthday = datetime(today.year, birthday.month, birthday.day)\n    # if it has gone by, when will it be next year\n    if today > next_birthday:\n        next_birthday = datetime(today.year+1, birthday.month, birthday.day)\n    # subtraction on datetime objects returns a timedelta object\n    delta = next_birthday - today",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "double_day",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def double_day(b1, b2):\n    \"\"\"Compute the day when one person is twice as old as the other.\n    b1: datetime birthday of the younger person\n    b2: datetime birthday of the older person\n    \"\"\"\n    assert b1 > b2\n    delta = b1 - b2\n    dday = b1 + delta\n    return dday\ndef datetime_exercises():",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "datetime_exercises",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def datetime_exercises():\n    \"\"\"Exercise solutions.\"\"\"\n    # print today's day of the week\n    today = datetime.today()\n    print(today.weekday())\n    print(today.strftime('%A'))\n    # compute the number of days until the next birthday\n    # (note that it usually gets rounded down)\n    birthday = datetime(1967, 5, 2)\n    print('Days until birthday', end=' ')",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Time1_soln",
        "description": "code.Time1_soln",
        "peekOfCode": "def main():\n    # if a movie starts at noon...\n    noon_time = Time()\n    noon_time.hour = 12\n    noon_time.minute = 0\n    noon_time.second = 0\n    print('Starts at', end=' ')\n    print_time(noon_time)\n    # and the run time of the movie is 109 minutes...\n    movie_minutes = 109",
        "detail": "code.Time1_soln",
        "documentation": {}
    },
    {
        "label": "Time",
        "kind": 6,
        "importPath": "code.Time2",
        "description": "code.Time2",
        "peekOfCode": "class Time:\n    \"\"\"Represents the time of day.\n    attributes: hour, minute, second\n    \"\"\"\n    def __init__(self, hour=0, minute=0, second=0):\n        \"\"\"Initializes a time object.\n        hour: int\n        minute: int\n        second: int or float\n        \"\"\"",
        "detail": "code.Time2",
        "documentation": {}
    },
    {
        "label": "int_to_time",
        "kind": 2,
        "importPath": "code.Time2",
        "description": "code.Time2",
        "peekOfCode": "def int_to_time(seconds):\n    \"\"\"Makes a new Time object.\n    seconds: int seconds since midnight.\n    \"\"\"\n    minutes, second = divmod(seconds, 60)\n    hour, minute = divmod(minutes, 60)\n    time = Time(hour, minute, second)\n    return time\ndef main():\n    start = Time(9, 45, 00)",
        "detail": "code.Time2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Time2",
        "description": "code.Time2",
        "peekOfCode": "def main():\n    start = Time(9, 45, 00)\n    start.print_time()\n    end = start.increment(1337)\n    #end = start.increment(1337, 460)\n    end.print_time()\n    print('Is end after start?')\n    print(end.is_after(start))\n    print('Using __str__')\n    print(start, end)",
        "detail": "code.Time2",
        "documentation": {}
    },
    {
        "label": "Time",
        "kind": 6,
        "importPath": "code.Time2_soln",
        "description": "code.Time2_soln",
        "peekOfCode": "class Time:\n    \"\"\"Represents the time of day.\n    attributes: hour, minute, second\n    \"\"\"\n    def __init__(self, hour=0, minute=0, second=0):\n        \"\"\"Initializes a time object.\n        hour: int\n        minute: int\n        second: int or float\n        \"\"\"",
        "detail": "code.Time2_soln",
        "documentation": {}
    },
    {
        "label": "int_to_time",
        "kind": 2,
        "importPath": "code.Time2_soln",
        "description": "code.Time2_soln",
        "peekOfCode": "def int_to_time(seconds):\n    \"\"\"Makes a new Time object.\n    seconds: int seconds since midnight.\n    \"\"\"\n    return Time(0, 0, seconds)\ndef main():\n    start = Time(9, 45, 00)\n    start.print_time()\n    end = start.increment(1337)\n    end.print_time()",
        "detail": "code.Time2_soln",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.Time2_soln",
        "description": "code.Time2_soln",
        "peekOfCode": "def main():\n    start = Time(9, 45, 00)\n    start.print_time()\n    end = start.increment(1337)\n    end.print_time()\n    print('Is end after start?')\n    print(end.is_after(start))\n    print('Using __str__')\n    print(start, end)\n    start = Time(9, 45)",
        "detail": "code.Time2_soln",
        "documentation": {}
    },
    {
        "label": "ackermann",
        "kind": 2,
        "importPath": "code.ackermann",
        "description": "code.ackermann",
        "peekOfCode": "def ackermann(m, n):\n    \"\"\"Computes the Ackermann function A(m, n)\n    See http://en.wikipedia.org/wiki/Ackermann_function\n    n, m: non-negative integers\n    \"\"\"\n    if m == 0:\n        return n+1\n    if n == 0:\n        return ackermann(m-1, 1)\n    return ackermann(m-1, ackermann(m, n-1))",
        "detail": "code.ackermann",
        "documentation": {}
    },
    {
        "label": "ackermann",
        "kind": 2,
        "importPath": "code.ackermann_memo",
        "description": "code.ackermann_memo",
        "peekOfCode": "def ackermann(m, n):\n    \"\"\"Computes the Ackermann function A(m, n)\n    See http://en.wikipedia.org/wiki/Ackermann_function\n    n, m: non-negative integers\n    \"\"\"\n    if m == 0:\n        return n+1\n    if n == 0:\n        return ackermann(m-1, 1)\n    if (m, n) in cache:",
        "detail": "code.ackermann_memo",
        "documentation": {}
    },
    {
        "label": "cache",
        "kind": 5,
        "importPath": "code.ackermann_memo",
        "description": "code.ackermann_memo",
        "peekOfCode": "cache = {}\ndef ackermann(m, n):\n    \"\"\"Computes the Ackermann function A(m, n)\n    See http://en.wikipedia.org/wiki/Ackermann_function\n    n, m: non-negative integers\n    \"\"\"\n    if m == 0:\n        return n+1\n    if n == 0:\n        return ackermann(m-1, 1)",
        "detail": "code.ackermann_memo",
        "documentation": {}
    },
    {
        "label": "store_anagrams",
        "kind": 2,
        "importPath": "code.anagram_db",
        "description": "code.anagram_db",
        "peekOfCode": "def store_anagrams(filename, anagram_map):\n    \"\"\"Stores the anagrams from a dictionary in a shelf.\n    filename: string file name of shelf\n    anagram_map: dictionary that maps strings to list of anagrams\n    \"\"\"\n    shelf = shelve.open(filename, 'c')\n    for word, word_list in anagram_map.items():\n        shelf[word] = word_list\n    shelf.close()\ndef read_anagrams(filename, word):",
        "detail": "code.anagram_db",
        "documentation": {}
    },
    {
        "label": "read_anagrams",
        "kind": 2,
        "importPath": "code.anagram_db",
        "description": "code.anagram_db",
        "peekOfCode": "def read_anagrams(filename, word):\n    \"\"\"Looks up a word in a shelf and returns a list of its anagrams.\n    filename: string file name of shelf\n    word: word to look up\n    \"\"\"\n    shelf = shelve.open(filename)\n    sig = signature(word)\n    try:\n        return shelf[sig]\n    except KeyError:",
        "detail": "code.anagram_db",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.anagram_db",
        "description": "code.anagram_db",
        "peekOfCode": "def main(script, command='make_db'):\n    if command == 'make_db':\n        anagram_map = all_anagrams('words.txt')\n        store_anagrams('anagrams.db', anagram_map)\n    else:\n        print(read_anagrams('anagrams.db', command))\nif __name__ == '__main__':\n    main(*sys.argv)",
        "detail": "code.anagram_db",
        "documentation": {}
    },
    {
        "label": "signature",
        "kind": 2,
        "importPath": "code.anagram_sets",
        "description": "code.anagram_sets",
        "peekOfCode": "def signature(s):\n    \"\"\"Returns the signature of this string.\n    Signature is a string that contains all of the letters in order.\n    s: string\n    \"\"\"\n    # TODO: rewrite using sorted()\n    t = list(s)\n    t.sort()\n    t = ''.join(t)\n    # 将单词转成字符串列表，进行排序后再拼接成字母字符串。",
        "detail": "code.anagram_sets",
        "documentation": {}
    },
    {
        "label": "all_anagrams",
        "kind": 2,
        "importPath": "code.anagram_sets",
        "description": "code.anagram_sets",
        "peekOfCode": "def all_anagrams(filename):\n    \"\"\"Finds all anagrams in a list of words.\n    filename: string filename of the word list\n    Returns: a map from each word to a list of its anagrams.\n    \"\"\"\n    # anagrams 颠倒字母而成的字\n    d = {}\n    for line in open(filename):\n        word = line.strip().lower()\n        t = signature(word)",
        "detail": "code.anagram_sets",
        "documentation": {}
    },
    {
        "label": "print_anagram_sets",
        "kind": 2,
        "importPath": "code.anagram_sets",
        "description": "code.anagram_sets",
        "peekOfCode": "def print_anagram_sets(d):\n    \"\"\"Prints the anagram sets in d.\n    d: map from words to list of their anagrams\n    \"\"\"\n    for v in d.values():\n        if len(v) > 1:\n            print(len(v), v)\ndef print_anagram_sets_in_order(d):\n    \"\"\"Prints the anagram sets in d in decreasing order of size.\n    按从大到小递减的顺序打印 d 中的字符集",
        "detail": "code.anagram_sets",
        "documentation": {}
    },
    {
        "label": "print_anagram_sets_in_order",
        "kind": 2,
        "importPath": "code.anagram_sets",
        "description": "code.anagram_sets",
        "peekOfCode": "def print_anagram_sets_in_order(d):\n    \"\"\"Prints the anagram sets in d in decreasing order of size.\n    按从大到小递减的顺序打印 d 中的字符集\n    d: map from words to list of their anagrams\n    d: 将单词映射到它们的字符列表。\n    \"\"\"\n    # make a list of (length, word pairs)\n    t = []\n    for v in d.values():\n        # 遍历每个元素，将字符按照长度作key来存放，value是字符",
        "detail": "code.anagram_sets",
        "documentation": {}
    },
    {
        "label": "filter_length",
        "kind": 2,
        "importPath": "code.anagram_sets",
        "description": "code.anagram_sets",
        "peekOfCode": "def filter_length(d, n):\n    \"\"\"Select only the words in d that have n letters.\n    d: map from word to list of anagrams\n    n: integer number of letters\n    returns: new map from word to list of anagrams\n    \"\"\"\n    res = {}\n    # 这里是将字典遍历，取出变位词和对应的单词列表。如果长度等于8，将单词列表写入。\n    for word, anagrams in d.items():\n        if len(word) == n:",
        "detail": "code.anagram_sets",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def process_file(filename, skip_header):\n    \"\"\"Makes a histogram that contains the words from a file.\n    pricess_file 遍历文件中的每一行，同时将每行内容逐次传递给 process_line.\n    词频 hist 在此处作为累加器使用。\n    filename: string\n    skip_header: boolean, whether to skip the Gutenberg header\n    returns: map from each word to the number of times it appears.\n    \"\"\"\n    hist = {}\n    fp = open(filename)",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "skip_gutenberg_header",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def skip_gutenberg_header(fp):\n    \"\"\"Reads from fp until it finds the line that ends the header.\n    fp: open file object\n    \"\"\"\n    for line in fp:\n        if line.startswith('*** START OF THIS'):\n            break\ndef process_line(line, hist):\n    \"\"\"Adds the words in the line to the histogram.\n    Modifies hist.",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "process_line",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def process_line(line, hist):\n    \"\"\"Adds the words in the line to the histogram.\n    Modifies hist.\n    line: string\n    hist: histogram (map from word to frequency)\n    \"\"\"\n    # TODO: rewrite using Counter\n    # replace hyphens with spaces before splitting\n    # 将分隔前的连字符 '-' 替换为空格 ' '\n    line = line.replace('-', ' ')",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "most_common",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def most_common(hist):\n    \"\"\"Makes a list of word-freq pairs in descending order of frequency.\n    hist: map from word to frequency\n    returns: list of (frequency, word) pairs\n    \"\"\"\n    t = []\n    for key, value in hist.items():\n        t.append((value, key))\n    # 将词频词典遍历，取出次数当值，key变成value，变成新字典列表。\n    # 所有结果入列表后，先排一次序，然后再反转，将列表倒序。",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "print_most_common",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def print_most_common(hist, num=10):\n    \"\"\"Prints the most commons words in a histgram and their frequencies.\n    hist: histogram (map from word to frequency)\n    num: number of words to print\n    \"\"\"\n    t = most_common(hist)\n    print('The most common words are:')\n    for freq, word in t[:num]:\n        print(word, '\\t', freq)\ndef subtract(d1, d2):",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "subtract",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def subtract(d1, d2):\n    \"\"\"Returns a dictionary with all keys that appear in d1 but not d2.\n    返回一个字典，其中包含 d1 中出现但 d2 中不出现但所有键。\n    d1, d2: dictionaries\n    \"\"\"\n    # TODO: reimplement using Counter\n    res = {}\n    # 遍历字典1，取出每个值，然后判断是否存在d2里，如果不存在的写入字典。\n    for key in d1:\n        if key not in d2:",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "total_words",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def total_words(hist):\n    \"\"\"Returns the total of the frequencies in a histogram.\"\"\"\n    # 通过sum来获得hist的值，我怎么想不到。sum里面也是一个迭代器，我传入字典的value集合就取出来值。\n    return sum(hist.values())\ndef different_words(hist):\n    \"\"\"Returns the number of different words in a histogram.\"\"\"\n    # 而这里更是简单，直接计算字典的大小就得到了不同单词的数量，不用管values。\n    # 都是对基础操作的灵活应用，而我因为没有熟练掌握，所以对这样的功能实现束手无策。\n    # 正是这样每一步都差一点儿，所以才做不成好的工程师，所以开发效率极慢。\n    # 这和使用什么语言编码都毫无关系，我的Java编程能力也不行，现在来看Python更轻便快捷。",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "different_words",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def different_words(hist):\n    \"\"\"Returns the number of different words in a histogram.\"\"\"\n    # 而这里更是简单，直接计算字典的大小就得到了不同单词的数量，不用管values。\n    # 都是对基础操作的灵活应用，而我因为没有熟练掌握，所以对这样的功能实现束手无策。\n    # 正是这样每一步都差一点儿，所以才做不成好的工程师，所以开发效率极慢。\n    # 这和使用什么语言编码都毫无关系，我的Java编程能力也不行，现在来看Python更轻便快捷。\n    return len(hist)\ndef random_word(hist):\n    \"\"\"Chooses a random word from a histogram.\n    The probability of each word is proportional to its frequency.",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "random_word",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def random_word(hist):\n    \"\"\"Chooses a random word from a histogram.\n    The probability of each word is proportional to its frequency.\n    \"\"\"\n    # TODO: rewrite using Counter\n    t = []\n    # 这里是将所有单词都放入集合列表里，一个单词出现多少次就复制多少遍，\n    # 然后用random.choice()从里面随机取一个，就实现了按词频正比返回随机数了。\n    for word, freq in hist.items():\n        t.extend([word] * freq)",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.analyze_book1",
        "description": "code.analyze_book1",
        "peekOfCode": "def main():\n    hist = process_file('/Users/dengwentao/work/python_project/ThinkPython2-CN/code/158-0.txt', skip_header=True)\n    print('Total number of words:', total_words(hist))\n    print('Number of different words:', different_words(hist))\n    t = most_common(hist)\n    print('The most common words are:')\n    # 使用切片取出前20个。t[0:20]\n    for freq, word in t[0:20]:\n        print(word, '\\t', freq)\n    words = process_file('/Users/dengwentao/work/python_project/ThinkPython2-CN/code/words.txt', skip_header=False)",
        "detail": "code.analyze_book1",
        "documentation": {}
    },
    {
        "label": "subtract",
        "kind": 2,
        "importPath": "code.analyze_book2",
        "description": "code.analyze_book2",
        "peekOfCode": "def subtract(d1, d2):\n    \"\"\"Returns a set of all keys that appear in d1 but not d2.\n    d1, d2: dictionaries\n    \"\"\"\n    return set(d1) - set(d2)\ndef main():\n    hist = process_file('158-0.txt', skip_header=True)\n    words = process_file('words.txt', skip_header=False)\n    diff = subtract(hist, words)\n    print(\"The words in the book that aren't in the word list are:\")",
        "detail": "code.analyze_book2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.analyze_book2",
        "description": "code.analyze_book2",
        "peekOfCode": "def main():\n    hist = process_file('158-0.txt', skip_header=True)\n    words = process_file('words.txt', skip_header=False)\n    diff = subtract(hist, words)\n    print(\"The words in the book that aren't in the word list are:\")\n    for word in diff:\n        print(word, end=' ')\nif __name__ == '__main__':\n    main()",
        "detail": "code.analyze_book2",
        "documentation": {}
    },
    {
        "label": "random_word",
        "kind": 2,
        "importPath": "code.analyze_book3",
        "description": "code.analyze_book3",
        "peekOfCode": "def random_word(hist):\n    \"\"\"Chooses a random word from a histogram.\n    The probability of each word is proportional to its frequency.\n    hist: map from word to frequency\n    \"\"\"\n    # TODO: This could be made faster by computing the cumulative\n    # frequencies once and reusing them.\n    words = []\n    freqs = []\n    total_freq = 0",
        "detail": "code.analyze_book3",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.analyze_book3",
        "description": "code.analyze_book3",
        "peekOfCode": "def main():\n    hist = process_file('158-0.txt', skip_header=True)\n    print(\"\\n\\nHere are some random words from the book\")\n    for i in range(100):\n        print(random_word(hist), end=' ')\nif __name__ == '__main__':\n    main()",
        "detail": "code.analyze_book3",
        "documentation": {}
    },
    {
        "label": "has_duplicates",
        "kind": 2,
        "importPath": "code.birthday",
        "description": "code.birthday",
        "peekOfCode": "def has_duplicates(t):\n    \"\"\"Returns True if any element appears more than once in a sequence.\n    t: list\n    returns: bool\n    \"\"\"\n    # make a copy of t to avoid modifying the parameter\n    s = t[:]\n    s.sort()\n    # check for adjacent elements that are equal\n    for i in range(len(s)-1):",
        "detail": "code.birthday",
        "documentation": {}
    },
    {
        "label": "random_bdays",
        "kind": 2,
        "importPath": "code.birthday",
        "description": "code.birthday",
        "peekOfCode": "def random_bdays(n):\n    \"\"\"Returns a list of integers between 1 and 365, with length n.\n    n: int\n    returns: list of int\n    \"\"\"\n    t = []\n    for i in range(n):\n        bday = random.randint(1, 365)\n        t.append(bday)\n    return t",
        "detail": "code.birthday",
        "documentation": {}
    },
    {
        "label": "count_matches",
        "kind": 2,
        "importPath": "code.birthday",
        "description": "code.birthday",
        "peekOfCode": "def count_matches(num_students, num_simulations):\n    \"\"\"Generates a sample of birthdays and counts duplicates.\n    num_students: how many students in the group\n    num_samples: how many groups to simulate\n    returns: int\n    \"\"\"\n    count = 0\n    for i in range(num_simulations):\n        t = random_bdays(num_students)\n        if has_duplicates(t):",
        "detail": "code.birthday",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.birthday",
        "description": "code.birthday",
        "peekOfCode": "def main():\n    \"\"\"Runs the birthday simulation and prints the number of matches.\"\"\"\n    num_students = 23\n    num_simulations = 1000\n    count = count_matches(num_students, num_simulations)\n    print('After %d simulations' % num_simulations)\n    print('with %d students' % num_students)\n    print('there were %d simulations with at least one match' % count)\nif __name__ == '__main__':\n    main()",
        "detail": "code.birthday",
        "documentation": {}
    },
    {
        "label": "easy_min",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "easy_min = 8 + 15 / 60\ntempo_min = 7 + 12 / 60\ntotal_min = 2 * easy_min + 3 * tempo_min\nprint('Total minutes:', total_min)\ntime_hour = 6 + 52 / 60 + total_min / 60\nprint('Time in hours', time_hour)\nhours = 7\nminutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "tempo_min",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "tempo_min = 7 + 12 / 60\ntotal_min = 2 * easy_min + 3 * tempo_min\nprint('Total minutes:', total_min)\ntime_hour = 6 + 52 / 60 + total_min / 60\nprint('Time in hours', time_hour)\nhours = 7\nminutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "total_min",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "total_min = 2 * easy_min + 3 * tempo_min\nprint('Total minutes:', total_min)\ntime_hour = 6 + 52 / 60 + total_min / 60\nprint('Time in hours', time_hour)\nhours = 7\nminutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "time_hour",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "time_hour = 6 + 52 / 60 + total_min / 60\nprint('Time in hours', time_hour)\nhours = 7\nminutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "hours",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "hours = 7\nminutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "minutes",
        "kind": 5,
        "importPath": "code.breakfast",
        "description": "code.breakfast",
        "peekOfCode": "minutes = (time_hour - hours) * 60\nprint('Time in hours and minutes', hours, minutes)",
        "detail": "code.breakfast",
        "documentation": {}
    },
    {
        "label": "is_triple_double",
        "kind": 2,
        "importPath": "code.cartalk1",
        "description": "code.cartalk1",
        "peekOfCode": "def is_triple_double(word):\n    \"\"\"Tests if a word contains three consecutive double letters.\n    word: string\n    returns: bool\n    \"\"\"\n    i = 0\n    count = 0\n    while i < len(word)-1:\n        if word[i] == word[i+1]:\n            count = count + 1",
        "detail": "code.cartalk1",
        "documentation": {}
    },
    {
        "label": "find_triple_double",
        "kind": 2,
        "importPath": "code.cartalk1",
        "description": "code.cartalk1",
        "peekOfCode": "def find_triple_double():\n    \"\"\"Reads a word list and prints words with triple double letters.\"\"\"\n    fin = open('words.txt')\n    for line in fin:\n        word = line.strip()\n        if is_triple_double(word):\n            print(word)\nprint('Here are all the words in the list that have')\nprint('three consecutive double letters.')\nfind_triple_double()",
        "detail": "code.cartalk1",
        "documentation": {}
    },
    {
        "label": "has_palindrome",
        "kind": 2,
        "importPath": "code.cartalk2",
        "description": "code.cartalk2",
        "peekOfCode": "def has_palindrome(i, start, length):\n    \"\"\"Checks if the string representation of i has a palindrome.\n    i: integer\n    start: where in the string to start\n    length: length of the palindrome to check for\n    \"\"\"\n    s = str(i)[start:start+length]\n    return s[::-1] == s\ndef check(i):\n    \"\"\"Checks if the integer (i) has the desired properties.",
        "detail": "code.cartalk2",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "code.cartalk2",
        "description": "code.cartalk2",
        "peekOfCode": "def check(i):\n    \"\"\"Checks if the integer (i) has the desired properties.\n    i: int\n    \"\"\"\n    return (has_palindrome(i, 2, 4) and\n            has_palindrome(i+1, 1, 5) and\n            has_palindrome(i+2, 1, 4) and\n            has_palindrome(i+3, 0, 6))\ndef check_all():\n    \"\"\"Enumerate the six-digit numbers and print any winners.",
        "detail": "code.cartalk2",
        "documentation": {}
    },
    {
        "label": "check_all",
        "kind": 2,
        "importPath": "code.cartalk2",
        "description": "code.cartalk2",
        "peekOfCode": "def check_all():\n    \"\"\"Enumerate the six-digit numbers and print any winners.\n    \"\"\"\n    i = 100000\n    while i <= 999996:\n        if check(i):\n            print(i)\n        i = i + 1\nprint('The following are the possible odometer readings:')\ncheck_all()",
        "detail": "code.cartalk2",
        "documentation": {}
    },
    {
        "label": "str_fill",
        "kind": 2,
        "importPath": "code.cartalk3",
        "description": "code.cartalk3",
        "peekOfCode": "def str_fill(i, n):\n    \"\"\"Returns i as a string with at least n digits.\n    i: int\n    n: int length\n    returns: string\n    \"\"\"\n    return str(i).zfill(n)\ndef are_reversed(i, j):\n    \"\"\"Checks if i and j are the reverse of each other.\n    i: int",
        "detail": "code.cartalk3",
        "documentation": {}
    },
    {
        "label": "are_reversed",
        "kind": 2,
        "importPath": "code.cartalk3",
        "description": "code.cartalk3",
        "peekOfCode": "def are_reversed(i, j):\n    \"\"\"Checks if i and j are the reverse of each other.\n    i: int\n    j: int\n    returns:bool\n    \"\"\"\n    return str_fill(i, 2) == str_fill(j, 2)[::-1]\ndef num_instances(diff, flag=False):\n    \"\"\"Counts the number of palindromic ages.\n    Returns the number of times the mother and daughter have",
        "detail": "code.cartalk3",
        "documentation": {}
    },
    {
        "label": "num_instances",
        "kind": 2,
        "importPath": "code.cartalk3",
        "description": "code.cartalk3",
        "peekOfCode": "def num_instances(diff, flag=False):\n    \"\"\"Counts the number of palindromic ages.\n    Returns the number of times the mother and daughter have\n    palindromic ages in their lives, given the difference in age.\n    diff: int difference in ages\n    flag: bool, if True, prints the details\n    \"\"\"\n    daughter = 0\n    count = 0\n    while True:",
        "detail": "code.cartalk3",
        "documentation": {}
    },
    {
        "label": "check_diffs",
        "kind": 2,
        "importPath": "code.cartalk3",
        "description": "code.cartalk3",
        "peekOfCode": "def check_diffs():\n    \"\"\"Finds age differences that satisfy the problem.\n    Enumerates the possible differences in age between mother\n    and daughter, and for each difference, counts the number of times\n    over their lives they will have ages that are the reverse of\n    each other.\n    \"\"\"\n    diff = 10\n    while diff < 70:\n        n = num_instances(diff)",
        "detail": "code.cartalk3",
        "documentation": {}
    },
    {
        "label": "do_twice",
        "kind": 2,
        "importPath": "code.do_four",
        "description": "code.do_four",
        "peekOfCode": "def do_twice(func, arg):\n    \"\"\"Runs a function twice.\n    func: function object\n    arg: argument passed to the function\n    \"\"\"\n    func(arg)\n    func(arg)\ndef print_twice(arg):\n    \"\"\"Prints the argument twice.\n    arg: anything printable",
        "detail": "code.do_four",
        "documentation": {}
    },
    {
        "label": "print_twice",
        "kind": 2,
        "importPath": "code.do_four",
        "description": "code.do_four",
        "peekOfCode": "def print_twice(arg):\n    \"\"\"Prints the argument twice.\n    arg: anything printable\n    \"\"\"\n    print(arg)\n    print(arg)\ndef do_four(func, arg):\n    \"\"\"Runs a function four times.\n    func: function object\n    arg: argument passed to the function",
        "detail": "code.do_four",
        "documentation": {}
    },
    {
        "label": "do_four",
        "kind": 2,
        "importPath": "code.do_four",
        "description": "code.do_four",
        "peekOfCode": "def do_four(func, arg):\n    \"\"\"Runs a function four times.\n    func: function object\n    arg: argument passed to the function\n    \"\"\"\n    do_twice(func, arg)\n    do_twice(func, arg)\ndo_twice(print, 'spam')\nprint('')\ndo_four(print, 'spam')",
        "detail": "code.do_four",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.double",
        "description": "code.double",
        "peekOfCode": "def main():\n    print(\"Today's date and the day of the week:\")\n    today = datetime.today()\n    print(today)\n    print(today.strftime(\"%A\"))\n    print(\"Your next birthday and how far away it is:\")\n    #s = input('Enter your birthday in mm/dd/yyyy format: ')\n    s = '5/11/1967'\n    bday = datetime.strptime(s, '%m/%d/%Y')\n    next_bday = bday.replace(year=today.year)",
        "detail": "code.double",
        "documentation": {}
    },
    {
        "label": "draw_circle",
        "kind": 2,
        "importPath": "code.draw",
        "description": "code.draw",
        "peekOfCode": "def draw_circle(t, circle):\n    \"\"\"Draws a circle.\n    t: Turtle\n    circle: Circle\n    \"\"\"\n    t.pu()\n    t.goto(circle.center.x, circle.center.y)\n    t.fd(circle.radius)\n    t.lt(90)\n    t.pd()",
        "detail": "code.draw",
        "documentation": {}
    },
    {
        "label": "draw_rect",
        "kind": 2,
        "importPath": "code.draw",
        "description": "code.draw",
        "peekOfCode": "def draw_rect(t, rect):\n    \"\"\"Draws a rectangle.\n    t: Turtle\n    rect: Rectangle\n    \"\"\"\n    t.pu()\n    t.goto(rect.corner.x, rect.corner.y)\n    t.setheading(0)\n    t.pd()\n    for length in rect.width, rect.height, rect.width, rect.height:",
        "detail": "code.draw",
        "documentation": {}
    },
    {
        "label": "walk",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def walk(dirname):\n    \"\"\"Finds the names of all files in dirname and its subdirectories.\n    dirname: string name of directory\n    \"\"\"\n    names = []\n    if '__pycache__' in dirname:\n        return names\n    for name in os.listdir(dirname):\n        path = os.path.join(dirname, name)\n        if os.path.isfile(path):",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "compute_checksum",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def compute_checksum(filename):\n    \"\"\"Computes the MD5 checksum of the contents of a file.\n    filename: string\n    \"\"\"\n    # Note: installing md5sha1sum is required\n    cmd = 'md5sum ' + filename\n    return pipe(cmd)\ndef check_diff(name1, name2):\n    \"\"\"Computes the difference between the contents of two files.\n    name1, name2: string filenames",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "check_diff",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def check_diff(name1, name2):\n    \"\"\"Computes the difference between the contents of two files.\n    name1, name2: string filenames\n    \"\"\"\n    cmd = 'diff %s %s' % (name1, name2)\n    return pipe(cmd)\ndef pipe(cmd):\n    \"\"\"Runs a command in a subprocess.\n    cmd: string Unix command\n    Returns (res, stat), the output of the subprocess and the exit status.",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def pipe(cmd):\n    \"\"\"Runs a command in a subprocess.\n    cmd: string Unix command\n    Returns (res, stat), the output of the subprocess and the exit status.\n    \"\"\"\n    # Note: os.popen is deprecated\n    # now, which means we are supposed to stop using it and start using\n    # the subprocess module.  But for simple cases, I find\n    # subprocess more complicated than necessary.  So I am going\n    # to keep using os.popen until they take it away.",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "compute_checksums",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def compute_checksums(dirname, suffix):\n    \"\"\"Computes checksums for all files with the given suffix.\n    dirname: string name of directory to search\n    suffix: string suffix to match\n    Returns: map from checksum to list of files with that checksum\n    \"\"\"\n    names = walk(dirname)\n    d = {}\n    for name in names:\n        if name.endswith(suffix):",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "check_pairs",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def check_pairs(names):\n    \"\"\"Checks whether any in a list of files differs from the others.\n    names: list of string filenames\n    \"\"\"\n    for name1 in names:\n        for name2 in names:\n            if name1 < name2:\n                res, stat = check_diff(name1, name2)\n                if res:\n                    return False",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "print_duplicates",
        "kind": 2,
        "importPath": "code.find_duplicates",
        "description": "code.find_duplicates",
        "peekOfCode": "def print_duplicates(d):\n    \"\"\"Checks for duplicate files.\n    Reports any files with the same checksum and checks whether they\n    are, in fact, identical.\n    d: map from checksum to list of files with that checksum\n    \"\"\"\n    for key, names in d.items():\n        if len(names) > 1:\n            print('The following files have the same checksum:')\n            for name in names:",
        "detail": "code.find_duplicates",
        "documentation": {}
    },
    {
        "label": "walk",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def walk(dirname):\n    \"\"\"Finds the names of all files in dirname and its subdirectories.\n    dirname: string name of directory\n    \"\"\"\n    names = []\n    if '__pycache__' in dirname:\n        return names\n    for name in os.listdir(dirname):\n        path = os.path.join(dirname, name)\n        if os.path.isfile(path):",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "compute_checksum",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def compute_checksum(filename):\n    \"\"\"Computes the MD5 checksum of the contents of a file.\n    filename: string\n    \"\"\"\n    cmd = 'md5sum ' + filename\n    return pipe(cmd)\ndef check_diff(name1, name2):\n    \"\"\"Computes the difference between the contents of two files.\n    name1, name2: string filenames\n    \"\"\"",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "check_diff",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def check_diff(name1, name2):\n    \"\"\"Computes the difference between the contents of two files.\n    name1, name2: string filenames\n    \"\"\"\n    cmd = 'diff %s %s' % (name1, name2)\n    return pipe(cmd)\ndef pipe(cmd):\n    \"\"\"Runs a command in a subprocess.\n    cmd: string Unix command\n    Returns (res, stat), the output of the subprocess and the exit status.",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def pipe(cmd):\n    \"\"\"Runs a command in a subprocess.\n    cmd: string Unix command\n    Returns (res, stat), the output of the subprocess and the exit status.\n    \"\"\"\n    # Note: os.popen is deprecated\n    # now, which means we are supposed to stop using it and start using\n    # the subprocess module.  But for simple cases, I find\n    # subprocess more complicated than necessary.  So I am going\n    # to keep using os.popen until they take it away.",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "compute_checksums",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def compute_checksums(dirname, suffix):\n    \"\"\"Computes checksums for all files with the given suffix.\n    dirname: string name of directory to search\n    suffix: string suffix to match\n    Returns: map from checksum to list of files with that checksum\n    \"\"\"\n    names = walk(dirname)\n    d = {}\n    for name in names:\n        if name.endswith(suffix):",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "check_pairs",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def check_pairs(names):\n    \"\"\"Checks whether any in a list of files differs from the others.\n    names: list of string filenames\n    \"\"\"\n    for name1 in names:\n        for name2 in names:\n            if name1 < name2:\n                res, stat = check_diff(name1, name2)\n                if res:\n                    return False",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "print_duplicates",
        "kind": 2,
        "importPath": "code.find_duplicates_copy",
        "description": "code.find_duplicates_copy",
        "peekOfCode": "def print_duplicates(d):\n    \"\"\"Checks for duplicate files.\n    Reports any files with the same checksum and checks whether they\n    are, in fact, identical.\n    d: map from checksum to list of files with that checksum\n    \"\"\"\n    for key, names in d.items():\n        if len(names) > 1:\n            print('The following files have the same checksum:')\n            for name in names:",
        "detail": "code.find_duplicates_copy",
        "documentation": {}
    },
    {
        "label": "petal",
        "kind": 2,
        "importPath": "code.flower",
        "description": "code.flower",
        "peekOfCode": "def petal(t, r, angle):\n    \"\"\"Draws a petal using two arcs.\n    t: Turtle\n    r: radius of the arcs\n    angle: angle (degrees) that subtends the arcs\n    \"\"\"\n    for i in range(2):\n        arc(t, r, angle)\n        t.lt(180-angle)\ndef flower(t, n, r, angle):",
        "detail": "code.flower",
        "documentation": {}
    },
    {
        "label": "flower",
        "kind": 2,
        "importPath": "code.flower",
        "description": "code.flower",
        "peekOfCode": "def flower(t, n, r, angle):\n    \"\"\"Draws a flower with n petals.\n    t: Turtle\n    n: number of petals\n    r: radius of the arcs\n    angle: angle (degrees) that subtends the arcs\n    \"\"\"\n    for i in range(n):\n        petal(t, r, angle)\n        t.lt(360.0/n)",
        "detail": "code.flower",
        "documentation": {}
    },
    {
        "label": "move",
        "kind": 2,
        "importPath": "code.flower",
        "description": "code.flower",
        "peekOfCode": "def move(t, length):\n    \"\"\"Move Turtle (t) forward (length) units without leaving a trail.\n    Leaves the pen down.\n    \"\"\"\n    t.pu()\n    t.fd(length)\n    t.pd()\nbob = turtle.Turtle()\n# draw a sequence of three flowers, as shown in the book.\nmove(bob, -100)",
        "detail": "code.flower",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.flower",
        "description": "code.flower",
        "peekOfCode": "bob = turtle.Turtle()\n# draw a sequence of three flowers, as shown in the book.\nmove(bob, -100)\nflower(bob, 7, 60.0, 60.0)\nmove(bob, 100)\nflower(bob, 10, 40.0, 80.0)\nmove(bob, 100)\nflower(bob, 20, 140.0, 20.0)\nbob.hideturtle()\nturtle.mainloop()",
        "detail": "code.flower",
        "documentation": {}
    },
    {
        "label": "do_twice",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def do_twice(f):\n    f()\n    f()\ndef do_four(f):\n    do_twice(f)\n    do_twice(f)\ndef print_beam():\n    print('+ - - - -', end=' ')\ndef print_post():\n    print('|        ', end=' ')",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "do_four",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def do_four(f):\n    do_twice(f)\n    do_twice(f)\ndef print_beam():\n    print('+ - - - -', end=' ')\ndef print_post():\n    print('|        ', end=' ')\ndef print_beams():\n    do_twice(print_beam)\n    print('+')",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_beam",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_beam():\n    print('+ - - - -', end=' ')\ndef print_post():\n    print('|        ', end=' ')\ndef print_beams():\n    do_twice(print_beam)\n    print('+')\ndef print_posts():\n    do_twice(print_post)\n    print('|')",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_post",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_post():\n    print('|        ', end=' ')\ndef print_beams():\n    do_twice(print_beam)\n    print('+')\ndef print_posts():\n    do_twice(print_post)\n    print('|')\ndef print_row():\n    print_beams()",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_beams",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_beams():\n    do_twice(print_beam)\n    print('+')\ndef print_posts():\n    do_twice(print_post)\n    print('|')\ndef print_row():\n    print_beams()\n    do_four(print_posts)\ndef print_grid():",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_posts",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_posts():\n    do_twice(print_post)\n    print('|')\ndef print_row():\n    print_beams()\n    do_four(print_posts)\ndef print_grid():\n    do_twice(print_row)\n    print_beams()\nprint_grid()",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_row",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_row():\n    print_beams()\n    do_four(print_posts)\ndef print_grid():\n    do_twice(print_row)\n    print_beams()\nprint_grid()\n# here is a less-straightforward solution to the\n# four-by-four grid\ndef one_four_one(f, g, h):",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_grid",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_grid():\n    do_twice(print_row)\n    print_beams()\nprint_grid()\n# here is a less-straightforward solution to the\n# four-by-four grid\ndef one_four_one(f, g, h):\n    f()\n    do_four(g)\n    h()",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "one_four_one",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def one_four_one(f, g, h):\n    f()\n    do_four(g)\n    h()\ndef print_plus():\n    print('+', end=' ')\ndef print_dash():\n    print('-', end=' ')\ndef print_bar():\n    print('|', end=' ')",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_plus",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_plus():\n    print('+', end=' ')\ndef print_dash():\n    print('-', end=' ')\ndef print_bar():\n    print('|', end=' ')\ndef print_space():\n    print(' ', end=' ')\ndef print_end():\n    print()",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_dash",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_dash():\n    print('-', end=' ')\ndef print_bar():\n    print('|', end=' ')\ndef print_space():\n    print(' ', end=' ')\ndef print_end():\n    print()\ndef nothing():\n    \"do nothing\"",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_bar",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_bar():\n    print('|', end=' ')\ndef print_space():\n    print(' ', end=' ')\ndef print_end():\n    print()\ndef nothing():\n    \"do nothing\"\ndef print1beam():\n    one_four_one(nothing, print_dash, print_plus)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_space",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_space():\n    print(' ', end=' ')\ndef print_end():\n    print()\ndef nothing():\n    \"do nothing\"\ndef print1beam():\n    one_four_one(nothing, print_dash, print_plus)\ndef print1post():\n    one_four_one(nothing, print_space, print_bar)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_end",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_end():\n    print()\ndef nothing():\n    \"do nothing\"\ndef print1beam():\n    one_four_one(nothing, print_dash, print_plus)\ndef print1post():\n    one_four_one(nothing, print_space, print_bar)\ndef print4beams():\n    one_four_one(print_plus, print1beam, print_end)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "nothing",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def nothing():\n    \"do nothing\"\ndef print1beam():\n    one_four_one(nothing, print_dash, print_plus)\ndef print1post():\n    one_four_one(nothing, print_space, print_bar)\ndef print4beams():\n    one_four_one(print_plus, print1beam, print_end)\ndef print4posts():\n    one_four_one(print_bar, print1post, print_end)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print1beam",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print1beam():\n    one_four_one(nothing, print_dash, print_plus)\ndef print1post():\n    one_four_one(nothing, print_space, print_bar)\ndef print4beams():\n    one_four_one(print_plus, print1beam, print_end)\ndef print4posts():\n    one_four_one(print_bar, print1post, print_end)\ndef print_row():\n    one_four_one(nothing, print4posts, print4beams)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print1post",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print1post():\n    one_four_one(nothing, print_space, print_bar)\ndef print4beams():\n    one_four_one(print_plus, print1beam, print_end)\ndef print4posts():\n    one_four_one(print_bar, print1post, print_end)\ndef print_row():\n    one_four_one(nothing, print4posts, print4beams)\ndef print_grid():\n    one_four_one(print4beams, print_row, nothing)",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print4beams",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print4beams():\n    one_four_one(print_plus, print1beam, print_end)\ndef print4posts():\n    one_four_one(print_bar, print1post, print_end)\ndef print_row():\n    one_four_one(nothing, print4posts, print4beams)\ndef print_grid():\n    one_four_one(print4beams, print_row, nothing)\nprint_grid()\ncomment = \"\"\"",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print4posts",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print4posts():\n    one_four_one(print_bar, print1post, print_end)\ndef print_row():\n    one_four_one(nothing, print4posts, print4beams)\ndef print_grid():\n    one_four_one(print4beams, print_row, nothing)\nprint_grid()\ncomment = \"\"\"\nAfter writing a draft of the 4x4 grid, I noticed that many of the\nfunctions had the same structure: they would do something, do",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_row",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_row():\n    one_four_one(nothing, print4posts, print4beams)\ndef print_grid():\n    one_four_one(print4beams, print_row, nothing)\nprint_grid()\ncomment = \"\"\"\nAfter writing a draft of the 4x4 grid, I noticed that many of the\nfunctions had the same structure: they would do something, do\nsomething else four times, and then do something else once.\nSo I wrote one_four_one, which takes three functions as arguments; it",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "print_grid",
        "kind": 2,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "def print_grid():\n    one_four_one(print4beams, print_row, nothing)\nprint_grid()\ncomment = \"\"\"\nAfter writing a draft of the 4x4 grid, I noticed that many of the\nfunctions had the same structure: they would do something, do\nsomething else four times, and then do something else once.\nSo I wrote one_four_one, which takes three functions as arguments; it\ncalls the first one once, then uses do_four to call the second one\nfour times, then calls the third.",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "comment",
        "kind": 5,
        "importPath": "code.grid",
        "description": "code.grid",
        "peekOfCode": "comment = \"\"\"\nAfter writing a draft of the 4x4 grid, I noticed that many of the\nfunctions had the same structure: they would do something, do\nsomething else four times, and then do something else once.\nSo I wrote one_four_one, which takes three functions as arguments; it\ncalls the first one once, then uses do_four to call the second one\nfour times, then calls the third.\nThen I rewrote print1beam, print1post, print4beams, print4posts,\nprint_row and print_grid using one_four_one.\nProgramming is an exploratory process.  Writing a draft of a program",
        "detail": "code.grid",
        "documentation": {}
    },
    {
        "label": "has_duplicates",
        "kind": 2,
        "importPath": "code.has_duplicates",
        "description": "code.has_duplicates",
        "peekOfCode": "def has_duplicates(t):\n    \"\"\"Checks whether any element appears more than once in a sequence.\n    Simple version using a for loop.\n    t: sequence\n    \"\"\"\n    # d = {}\n    # for x in t:\n    #     if x in d:\n    #         return True\n    #     d[x] = True",
        "detail": "code.has_duplicates",
        "documentation": {}
    },
    {
        "label": "has_duplicates2",
        "kind": 2,
        "importPath": "code.has_duplicates",
        "description": "code.has_duplicates",
        "peekOfCode": "def has_duplicates2(t):\n    \"\"\"Checks whether any element appears more than once in a sequence.\n    Faster version using a set.\n    t: sequence\n    \"\"\"\n    # 这个就简单多了，直接判断长度，如果是set集合，有重复的长度会减少。高下立判，不用循环遍历。\n    return len(set(t)) < len(t)\nif __name__ == '__main__':\n    t = [1, 2, 3]\n    print(has_duplicates(t))",
        "detail": "code.has_duplicates",
        "documentation": {}
    },
    {
        "label": "make_word_dict",
        "kind": 2,
        "importPath": "code.homophone",
        "description": "code.homophone",
        "peekOfCode": "def make_word_dict():\n    \"\"\"Read. the words in words.txt and return a dictionary\n    that contains the words as keys.\"\"\"\n    d = dict()\n    fin = open('words.txt')\n    for line in fin:\n        word = line.strip().lower()\n        d[word] = word\n    return d\ndef homophones(a, b, phonetic):",
        "detail": "code.homophone",
        "documentation": {}
    },
    {
        "label": "homophones",
        "kind": 2,
        "importPath": "code.homophone",
        "description": "code.homophone",
        "peekOfCode": "def homophones(a, b, phonetic):\n    \"\"\"Checks if words two can be pronounced the same way.\n    If either word is not in the pronouncing dictionary, return False\n    a, b: strings\n    phonetic: map from words to pronunciation codes\n    \"\"\"\n    if a not in phonetic or b not in phonetic:\n        return False\n    return phonetic[a] == phonetic[b]\ndef check_word(word, word_dict, phonetic):",
        "detail": "code.homophone",
        "documentation": {}
    },
    {
        "label": "check_word",
        "kind": 2,
        "importPath": "code.homophone",
        "description": "code.homophone",
        "peekOfCode": "def check_word(word, word_dict, phonetic):\n    \"\"\"Checks to see if the word has the following property:\n    removing the first letter yields a word with the same\n    pronunciation, and removing the second letter yields a word\n    with the same pronunciation.\n    word: string\n    word_dict: dictionary with words as keys\n    phonetic: map from words to pronunciation codes\n    \"\"\"\n    word1 = word[1:] ",
        "detail": "code.homophone",
        "documentation": {}
    },
    {
        "label": "make_word_list",
        "kind": 2,
        "importPath": "code.inlist",
        "description": "code.inlist",
        "peekOfCode": "def make_word_list():\n    \"\"\"Reads lines from a file and builds a list using append.\n    returns: list of strings\n    \"\"\"\n    word_list = []\n    fin = open('/Users/dengwentao/work/python_project/ThinkPython2-CN/code/words.txt')\n    for line in fin:\n        word = line.strip()\n        word_list.append(word)\n    return word_list",
        "detail": "code.inlist",
        "documentation": {}
    },
    {
        "label": "in_bisect",
        "kind": 2,
        "importPath": "code.inlist",
        "description": "code.inlist",
        "peekOfCode": "def in_bisect(word_list, word):\n    \"\"\"Checks whether a word is in a list using bisection search.\n    Precondition: the words in the list are sorted\n    word_list: list of strings\n    word: string\n    returns: True if the word is in the list; False otherwise\n    \"\"\"\n    # 单词列表已经排好序。列表长度如果为0直接返回false。\n    if len(word_list) == 0:\n        return False",
        "detail": "code.inlist",
        "documentation": {}
    },
    {
        "label": "in_bisect_cheat",
        "kind": 2,
        "importPath": "code.inlist",
        "description": "code.inlist",
        "peekOfCode": "def in_bisect_cheat(word_list, word):\n    \"\"\"Checks whether a word is in a list using bisection search.\n    Precondition: the words in the list are sorted\n    word_list: list of strings\n    word: string\n    \"\"\"\n    i = bisect.bisect_left(word_list, word)\n    if i == len(word_list):\n        return False\n    return word_list[i] == word",
        "detail": "code.inlist",
        "documentation": {}
    },
    {
        "label": "interlock",
        "kind": 2,
        "importPath": "code.interlock",
        "description": "code.interlock",
        "peekOfCode": "def interlock(word_list, word):\n    \"\"\"Checks whether a word contains two interleaved words.\n    word_list: list of strings\n    word: string\n    \"\"\"\n    evens = word[::2]\n    odds = word[1::2]\n    return in_bisect(word_list, evens) and in_bisect(word_list, odds) \ndef interlock_general(word_list, word, n=3):\n    \"\"\"Checks whether a word contains n interleaved words.",
        "detail": "code.interlock",
        "documentation": {}
    },
    {
        "label": "interlock_general",
        "kind": 2,
        "importPath": "code.interlock",
        "description": "code.interlock",
        "peekOfCode": "def interlock_general(word_list, word, n=3):\n    \"\"\"Checks whether a word contains n interleaved words.\n    word_list: list of strings\n    word: string\n    n: number of interleaved words\n    \"\"\"\n    for i in range(n):\n        inter = word[i::n]\n        if not in_bisect(word_list, inter):\n            return False",
        "detail": "code.interlock",
        "documentation": {}
    },
    {
        "label": "invert_dict",
        "kind": 2,
        "importPath": "code.invert_dict",
        "description": "code.invert_dict",
        "peekOfCode": "def invert_dict(d):\n    \"\"\"Inverts a dictionary, returning a map from val to a list of keys.\n    If the mapping key->val appears in d, then in the new dictionary\n    val maps to a list that includes key.\n    d: dict\n    Returns: dict\n    \"\"\"\n    inverse = {}\n    for key in d:\n        val = d[key]",
        "detail": "code.invert_dict",
        "documentation": {}
    },
    {
        "label": "koch",
        "kind": 2,
        "importPath": "code.koch",
        "description": "code.koch",
        "peekOfCode": "def koch(t, n):\n    \"\"\"Draws a koch curve with length n.\"\"\"\n    if n < 10:\n        t.fd(n)\n        return\n    m = n/3\n    koch(t, m)\n    t.lt(60)\n    koch(t, m)\n    t.rt(120)",
        "detail": "code.koch",
        "documentation": {}
    },
    {
        "label": "snowflake",
        "kind": 2,
        "importPath": "code.koch",
        "description": "code.koch",
        "peekOfCode": "def snowflake(t, n):\n    \"\"\"Draws a snowflake (a triangle with a Koch curve for each side).\"\"\"\n    for i in range(3):\n        koch(t, n)\n        t.rt(120)\nbob = turtle.Turtle()\nbob.pu()\nbob.goto(-150, 90)\nbob.pd()\nsnowflake(bob, 300)",
        "detail": "code.koch",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.koch",
        "description": "code.koch",
        "peekOfCode": "bob = turtle.Turtle()\nbob.pu()\nbob.goto(-150, 90)\nbob.pd()\nsnowflake(bob, 300)\nturtle.mainloop()",
        "detail": "code.koch",
        "documentation": {}
    },
    {
        "label": "fd",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def fd(t, length):\n    t.fd(length)\ndef bk(t, length):\n    t.bk(length)\ndef lt(t, angle=90):\n    t.lt(angle)\ndef rt(t, angle=90):\n    t.rt(angle)\ndef pd(t):\n    t.pd()",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "bk",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def bk(t, length):\n    t.bk(length)\ndef lt(t, angle=90):\n    t.lt(angle)\ndef rt(t, angle=90):\n    t.rt(angle)\ndef pd(t):\n    t.pd()\ndef pu(t):\n    t.pu()",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "lt",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def lt(t, angle=90):\n    t.lt(angle)\ndef rt(t, angle=90):\n    t.rt(angle)\ndef pd(t):\n    t.pd()\ndef pu(t):\n    t.pu()\n# LEVEL 1 PRIMITIVES are simple combinations of Level 0 primitives.\n# They have no pre- or post-conditions.",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "rt",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def rt(t, angle=90):\n    t.rt(angle)\ndef pd(t):\n    t.pd()\ndef pu(t):\n    t.pu()\n# LEVEL 1 PRIMITIVES are simple combinations of Level 0 primitives.\n# They have no pre- or post-conditions.\ndef fdlt(t, n, angle=90):\n    \"\"\"forward and left\"\"\"",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "pd",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def pd(t):\n    t.pd()\ndef pu(t):\n    t.pu()\n# LEVEL 1 PRIMITIVES are simple combinations of Level 0 primitives.\n# They have no pre- or post-conditions.\ndef fdlt(t, n, angle=90):\n    \"\"\"forward and left\"\"\"\n    fd(t, n)\n    lt(t, angle)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "pu",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def pu(t):\n    t.pu()\n# LEVEL 1 PRIMITIVES are simple combinations of Level 0 primitives.\n# They have no pre- or post-conditions.\ndef fdlt(t, n, angle=90):\n    \"\"\"forward and left\"\"\"\n    fd(t, n)\n    lt(t, angle)\ndef fdbk(t, n):\n    \"\"\"forward and back, ending at the original position\"\"\"",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "fdlt",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def fdlt(t, n, angle=90):\n    \"\"\"forward and left\"\"\"\n    fd(t, n)\n    lt(t, angle)\ndef fdbk(t, n):\n    \"\"\"forward and back, ending at the original position\"\"\"\n    fd(t, n)\n    bk(t, n)\ndef skip(t, n):\n    \"\"\"lift the pen and move\"\"\"",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "fdbk",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def fdbk(t, n):\n    \"\"\"forward and back, ending at the original position\"\"\"\n    fd(t, n)\n    bk(t, n)\ndef skip(t, n):\n    \"\"\"lift the pen and move\"\"\"\n    pu(t)\n    fd(t, n)\n    pd(t)\ndef stump(t, n, angle=90):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "skip",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def skip(t, n):\n    \"\"\"lift the pen and move\"\"\"\n    pu(t)\n    fd(t, n)\n    pd(t)\ndef stump(t, n, angle=90):\n    \"\"\"Makes a vertical line and leave the turtle at the top, facing right\"\"\"\n    lt(t)\n    fd(t, n)\n    rt(t, angle)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "stump",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def stump(t, n, angle=90):\n    \"\"\"Makes a vertical line and leave the turtle at the top, facing right\"\"\"\n    lt(t)\n    fd(t, n)\n    rt(t, angle)\ndef hollow(t, n):\n    \"\"\"move the turtle vertically and leave it at the top, facing right\"\"\"\n    lt(t)\n    skip(t, n)\n    rt(t)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "hollow",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def hollow(t, n):\n    \"\"\"move the turtle vertically and leave it at the top, facing right\"\"\"\n    lt(t)\n    skip(t, n)\n    rt(t)\n# LEVEL 2 PRIMITIVES use primitives from Levels 0 and 1\n# to draw posts (vertical elements) and beams (horizontal elements)\n# Level 2 primitives ALWAYS return the turtle to the original\n# location and direction.\ndef post(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "post",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def post(t, n):\n    \"\"\"Makes a vertical line and return to the original position\"\"\"\n    lt(t)\n    fdbk(t, n)\n    rt(t)\ndef beam(t, n, height):\n    \"\"\"Makes a horizontal line at the given height and return.\"\"\"\n    hollow(t, n*height)\n    fdbk(t, n)\n    hollow(t, -n*height)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "beam",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def beam(t, n, height):\n    \"\"\"Makes a horizontal line at the given height and return.\"\"\"\n    hollow(t, n*height)\n    fdbk(t, n)\n    hollow(t, -n*height)\ndef hangman(t, n, height):\n    \"\"\"Makes a vertical line to the given height and a horizontal line\n    at the given height and then return.\n    This is efficient to implement, and turns out to be useful, but\n    it's not so semantically clean.\"\"\"",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "hangman",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def hangman(t, n, height):\n    \"\"\"Makes a vertical line to the given height and a horizontal line\n    at the given height and then return.\n    This is efficient to implement, and turns out to be useful, but\n    it's not so semantically clean.\"\"\"\n    stump(t, n * height)\n    fdbk(t, n)\n    lt(t)\n    bk(t, n*height)\n    rt(t)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "diagonal",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def diagonal(t, x, y):\n    \"\"\"Makes a diagonal line to the given x, y offsets and return\"\"\"\n    from math import atan2, sqrt, pi\n    angle = atan2(y, x) * 180 / pi\n    dist = sqrt(x**2 + y**2)\n    lt(t, angle)\n    fdbk(t, dist)\n    rt(t, angle)\ndef vshape(t, n, height):\n    diagonal(t, -n/2, height*n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "vshape",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def vshape(t, n, height):\n    diagonal(t, -n/2, height*n)\n    diagonal(t, n/2, height*n)\ndef bump(t, n, height):\n    \"\"\"Makes a bump with radius n at height*n \n    \"\"\"\n    stump(t, n*height)\n    arc(t, n/2.0, 180)\n    lt(t)\n    fdlt(t, n*height+n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "bump",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def bump(t, n, height):\n    \"\"\"Makes a bump with radius n at height*n \n    \"\"\"\n    stump(t, n*height)\n    arc(t, n/2.0, 180)\n    lt(t)\n    fdlt(t, n*height+n)\n\"\"\"\nThe letter-drawing functions all have the precondition\nthat the turtle is in the lower-left corner of the letter,",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_a",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_a(t, n):\n    diagonal(t, n/2, 2*n)\n    beam(t, n, 1)\n    skip(t, n)\n    diagonal(t, -n/2, 2*n)\ndef draw_b(t, n):\n    bump(t, n, 1)\n    bump(t, n, 0)\n    skip(t, n/2)\ndef draw_c(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_b",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_b(t, n):\n    bump(t, n, 1)\n    bump(t, n, 0)\n    skip(t, n/2)\ndef draw_c(t, n):\n    hangman(t, n, 2)\n    fd(t, n)\ndef draw_d(t, n):\n    bump(t, 2*n, 0)\n    skip(t, n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_c",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_c(t, n):\n    hangman(t, n, 2)\n    fd(t, n)\ndef draw_d(t, n):\n    bump(t, 2*n, 0)\n    skip(t, n)\ndef draw_ef(t, n):\n    hangman(t, n, 2)\n    hangman(t, n, 1)\ndef draw_e(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_d",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_d(t, n):\n    bump(t, 2*n, 0)\n    skip(t, n)\ndef draw_ef(t, n):\n    hangman(t, n, 2)\n    hangman(t, n, 1)\ndef draw_e(t, n):\n    draw_ef(t, n)\n    fd(t, n)\ndef draw_f(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_ef",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_ef(t, n):\n    hangman(t, n, 2)\n    hangman(t, n, 1)\ndef draw_e(t, n):\n    draw_ef(t, n)\n    fd(t, n)\ndef draw_f(t, n):\n    draw_ef(t, n)\n    skip(t, n)\ndef draw_g(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_e",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_e(t, n):\n    draw_ef(t, n)\n    fd(t, n)\ndef draw_f(t, n):\n    draw_ef(t, n)\n    skip(t, n)\ndef draw_g(t, n):\n    hangman(t, n, 2)\n    fd(t, n/2)\n    beam(t, n/2, 2)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_f",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_f(t, n):\n    draw_ef(t, n)\n    skip(t, n)\ndef draw_g(t, n):\n    hangman(t, n, 2)\n    fd(t, n/2)\n    beam(t, n/2, 2)\n    fd(t, n/2)\n    post(t, n)\ndef draw_h(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_g",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_g(t, n):\n    hangman(t, n, 2)\n    fd(t, n/2)\n    beam(t, n/2, 2)\n    fd(t, n/2)\n    post(t, n)\ndef draw_h(t, n):\n    post(t, 2*n)\n    hangman(t, n, 1)\n    skip(t, n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_h",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_h(t, n):\n    post(t, 2*n)\n    hangman(t, n, 1)\n    skip(t, n)\n    post(t, 2*n)\ndef draw_i(t, n):\n    beam(t, n, 2)\n    fd(t, n/2)\n    post(t, 2*n)\n    fd(t, n/2)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_i",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_i(t, n):\n    beam(t, n, 2)\n    fd(t, n/2)\n    post(t, 2*n)\n    fd(t, n/2)\ndef draw_j(t, n):\n    beam(t, n, 2)\n    arc(t, n/2, 90)\n    fd(t, 3*n/2)\n    skip(t, -2*n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_j",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_j(t, n):\n    beam(t, n, 2)\n    arc(t, n/2, 90)\n    fd(t, 3*n/2)\n    skip(t, -2*n)\n    rt(t)\n    skip(t, n/2)\ndef draw_k(t, n):\n    post(t, 2*n)\n    stump(t, n, 180)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_k",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_k(t, n):\n    post(t, 2*n)\n    stump(t, n, 180)\n    vshape(t, 2*n, 0.5)\n    fdlt(t, n)\n    skip(t, n)\ndef draw_l(t, n):\n    post(t, 2*n)\n    fd(t, n)\ndef draw_n(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_l",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_l(t, n):\n    post(t, 2*n)\n    fd(t, n)\ndef draw_n(t, n):\n    post(t, 2*n)\n    skip(t, n)\n    diagonal(t, -n, 2*n)\n    post(t, 2*n)\ndef draw_m(t, n):\n    post(t, 2*n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_n",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_n(t, n):\n    post(t, 2*n)\n    skip(t, n)\n    diagonal(t, -n, 2*n)\n    post(t, 2*n)\ndef draw_m(t, n):\n    post(t, 2*n)\n    draw_v(t, n)\n    post(t, 2*n)\ndef draw_o(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_m",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_m(t, n):\n    post(t, 2*n)\n    draw_v(t, n)\n    post(t, 2*n)\ndef draw_o(t, n):\n    skip(t, n)\n    circle(t, n)\n    skip(t, n)\ndef draw_p(t, n):\n    bump(t, n, 1)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_o",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_o(t, n):\n    skip(t, n)\n    circle(t, n)\n    skip(t, n)\ndef draw_p(t, n):\n    bump(t, n, 1)\n    skip(t, n/2)\ndef draw_q(t, n):\n    draw_o(t, n)\n    diagonal(t, -n/2, n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_p",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_p(t, n):\n    bump(t, n, 1)\n    skip(t, n/2)\ndef draw_q(t, n):\n    draw_o(t, n)\n    diagonal(t, -n/2, n)\ndef draw_r(t, n):\n    draw_p(t, n)\n    diagonal(t, -n/2, n)\ndef draw_s(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_q",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_q(t, n):\n    draw_o(t, n)\n    diagonal(t, -n/2, n)\ndef draw_r(t, n):\n    draw_p(t, n)\n    diagonal(t, -n/2, n)\ndef draw_s(t, n):\n    fd(t, n/2)\n    arc(t, n/2, 180)\n    arc(t, n/2, -180)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_r",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_r(t, n):\n    draw_p(t, n)\n    diagonal(t, -n/2, n)\ndef draw_s(t, n):\n    fd(t, n/2)\n    arc(t, n/2, 180)\n    arc(t, n/2, -180)\n    fdlt(t, n/2, -90)\n    skip(t, 2*n)\n    lt(t)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_s",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_s(t, n):\n    fd(t, n/2)\n    arc(t, n/2, 180)\n    arc(t, n/2, -180)\n    fdlt(t, n/2, -90)\n    skip(t, 2*n)\n    lt(t)\ndef draw_t(t, n):\n    beam(t, n, 2)\n    skip(t, n/2)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_t",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_t(t, n):\n    beam(t, n, 2)\n    skip(t, n/2)\n    post(t, 2*n)\n    skip(t, n/2)\ndef draw_u(t, n):\n    post(t, 2*n)\n    fd(t, n)\n    post(t, 2*n)\ndef draw_v(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_u",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_u(t, n):\n    post(t, 2*n)\n    fd(t, n)\n    post(t, 2*n)\ndef draw_v(t, n):\n    skip(t, n/2)\n    vshape(t, n, 2)\n    skip(t, n/2)\ndef draw_w(t, n):\n    draw_v(t, n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_v",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_v(t, n):\n    skip(t, n/2)\n    vshape(t, n, 2)\n    skip(t, n/2)\ndef draw_w(t, n):\n    draw_v(t, n)\n    draw_v(t, n)\ndef draw_x(t, n):\n    diagonal(t, n, 2*n)\n    skip(t, n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_w",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_w(t, n):\n    draw_v(t, n)\n    draw_v(t, n)\ndef draw_x(t, n):\n    diagonal(t, n, 2*n)\n    skip(t, n)\n    diagonal(t, -n, 2*n)\ndef draw_v(t, n):\n    skip(t, n/2)\n    diagonal(t, -n/2, 2*n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_x",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_x(t, n):\n    diagonal(t, n, 2*n)\n    skip(t, n)\n    diagonal(t, -n, 2*n)\ndef draw_v(t, n):\n    skip(t, n/2)\n    diagonal(t, -n/2, 2*n)\n    diagonal(t, n/2, 2*n)\n    skip(t, n/2)\ndef draw_y(t, n):",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_v",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_v(t, n):\n    skip(t, n/2)\n    diagonal(t, -n/2, 2*n)\n    diagonal(t, n/2, 2*n)\n    skip(t, n/2)\ndef draw_y(t, n):\n    skip(t, n/2)\n    stump(t, n)\n    vshape(t, n, 1)\n    rt(t)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_y",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_y(t, n):\n    skip(t, n/2)\n    stump(t, n)\n    vshape(t, n, 1)\n    rt(t)\n    fdlt(t, n)\n    skip(t, n/2)\ndef draw_z(t, n):\n    beam(t, n, 2)\n    diagonal(t, n, 2*n)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_z",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_z(t, n):\n    beam(t, n, 2)\n    diagonal(t, n, 2*n)\n    fd(t, n)\ndef draw_(t, n):\n    # draw a space\n    skip(t, n)\nif __name__ == '__main__':\n    # create and position the turtle\n    size = 20",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "draw_",
        "kind": 2,
        "importPath": "code.letters",
        "description": "code.letters",
        "peekOfCode": "def draw_(t, n):\n    # draw a space\n    skip(t, n)\nif __name__ == '__main__':\n    # create and position the turtle\n    size = 20\n    bob = turtle.Turtle()\n    for f in [draw_h, draw_e, draw_l, draw_l, draw_o]:\n        f(bob, size)\n        skip(bob, size)",
        "detail": "code.letters",
        "documentation": {}
    },
    {
        "label": "nested_sum",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def nested_sum(t):\n    \"\"\"Computes the total of all numbers in a list of lists.\n    t: list of list of numbers\n    returns: number\n    \"\"\"\n    total = 0\n    for nested in t:\n        total += sum(nested)\n    return total\ndef cumsum(t):",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "cumsum",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def cumsum(t):\n    \"\"\"Computes the cumulative sum of the numbers in t.\n    t: list of numbers\n    returns: list of numbers\n    \"\"\"\n    total = 0\n    res = []\n    for x in t:\n        total += x\n        res.append(total)",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "middle",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def middle(t):\n    \"\"\"Returns all but the first and last elements of t.\n    t: list\n    returns: new list\n    \"\"\"\n    return t[1:-1]\ndef chop(t):\n    \"\"\"Removes the first and last elements of t.\n    t: list\n    returns: None",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "chop",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def chop(t):\n    \"\"\"Removes the first and last elements of t.\n    t: list\n    returns: None\n    \"\"\"\n    del t[0]\n    del t[-1]\ndef is_sorted(t):\n    \"\"\"Checks whether a list is sorted.\n    t: list",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "is_sorted",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def is_sorted(t):\n    \"\"\"Checks whether a list is sorted.\n    t: list\n    returns: boolean\n    \"\"\"\n    return t == sorted(t)\ndef is_anagram(word1, word2):\n    \"\"\"Checks whether two words are anagrams\n    word1: string or list\n    word2: string or list",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def is_anagram(word1, word2):\n    \"\"\"Checks whether two words are anagrams\n    word1: string or list\n    word2: string or list\n    returns: boolean\n    \"\"\"\n    return sorted(word1) == sorted(word2)\ndef has_duplicates(s):\n    \"\"\"Returns True if any element appears more than once in a sequence.\n    s: string or list",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "has_duplicates",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def has_duplicates(s):\n    \"\"\"Returns True if any element appears more than once in a sequence.\n    s: string or list\n    returns: bool\n    \"\"\"\n    # make a copy of t to avoid modifying the parameter\n    t = list(s)\n    t.sort()\n    # check for adjacent elements that are equal\n    for i in range(len(t)-1):",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.list_exercises",
        "description": "code.list_exercises",
        "peekOfCode": "def main():\n    t = [[1, 2], [3], [4, 5, 6]]\n    print(nested_sum(t))\n    t = [1, 2, 3]\n    print(cumsum(t))\n    t = [1, 2, 3, 4]\n    print(middle(t))\n    chop(t)\n    print(t)\n    print(is_sorted([1, 2, 2]))",
        "detail": "code.list_exercises",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def process_file(filename, order=2):\n    \"\"\"Reads a file and performs Markov analysis.\n    filename: string\n    order: integer number of words in the prefix\n    returns: map from prefix to list of possible suffixes.\n    \"\"\"\n    fp = open(filename)\n    skip_gutenberg_header(fp)\n    for line in fp:\n        if line.startswith('*** END OF THIS'): ",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "skip_gutenberg_header",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def skip_gutenberg_header(fp):\n    \"\"\"Reads from fp until it finds the line that ends the header.\n    fp: open file object\n    \"\"\"\n    for line in fp:\n        if line.startswith('*** START OF THIS'):\n            break\ndef process_word(word, order=2):\n    \"\"\"Processes each word.\n    word: string",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "process_word",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def process_word(word, order=2):\n    \"\"\"Processes each word.\n    word: string\n    order: integer\n    During the first few iterations, all we do is store up the words; \n    after that we start adding entries to the dictionary.\n    \"\"\"\n    global prefix\n    if len(prefix) < order:\n        prefix += (word,)",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "random_text",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def random_text(n=100):\n    \"\"\"Generates random wordsfrom the analyzed text.\n    Starts with a random prefix from the dictionary.\n    n: number of words to generate\n    \"\"\"\n    # choose a random prefix (not weighted by frequency)\n    start = random.choice(list(suffix_map.keys()))\n    for i in range(n):\n        suffixes = suffix_map.get(start, None)\n        if suffixes == None:",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "shift",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def shift(t, word):\n    \"\"\"Forms a new tuple by removing the head and adding word to the tail.\n    通过移除头部，并在尾部增加一个单词形成元组。\n    t: tuple of strings\n    word: string\n    Returns: tuple of strings\n    \"\"\"\n    return t[1:] + (word,)\ndef main(script, filename='/Users/dengwentao/work/python_project/ThinkPython2-CN/code/158-0.txt', n=100, order=2):\n    try:",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "def main(script, filename='/Users/dengwentao/work/python_project/ThinkPython2-CN/code/158-0.txt', n=100, order=2):\n    try:\n        n = int(n)\n        order = int(order)\n    except ValueError:\n        print('Usage: %d filename [# of words] [prefix length]' % script)\n    else: \n        process_file(filename, order)\n        random_text(n)\n        print()",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "suffix_map",
        "kind": 5,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "suffix_map = {}        # map from prefixes to a list of suffixes\nprefix = ()            # current tuple of words\ndef process_file(filename, order=2):\n    \"\"\"Reads a file and performs Markov analysis.\n    filename: string\n    order: integer number of words in the prefix\n    returns: map from prefix to list of possible suffixes.\n    \"\"\"\n    fp = open(filename)\n    skip_gutenberg_header(fp)",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "prefix",
        "kind": 5,
        "importPath": "code.markov",
        "description": "code.markov",
        "peekOfCode": "prefix = ()            # current tuple of words\ndef process_file(filename, order=2):\n    \"\"\"Reads a file and performs Markov analysis.\n    filename: string\n    order: integer number of words in the prefix\n    returns: map from prefix to list of possible suffixes.\n    \"\"\"\n    fp = open(filename)\n    skip_gutenberg_header(fp)\n    for line in fp:",
        "detail": "code.markov",
        "documentation": {}
    },
    {
        "label": "Markov",
        "kind": 6,
        "importPath": "code.markov2",
        "description": "code.markov2",
        "peekOfCode": "class Markov:\n    \"\"\"Encapsulates the statistical summary of a text.\"\"\"\n    def __init__(self):\n        self.suffix_map = {}        # map from prefixes to a list of suffixes\n        self.prefix = ()            # current tuple of words\n    def process_file(self, filename, order=2):\n        \"\"\"Reads a file and performs Markov analysis.\n        filename: string\n        order: integer number of words in the prefix\n        Returns: map from prefix to list of possible suffixes.",
        "detail": "code.markov2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.markov2",
        "description": "code.markov2",
        "peekOfCode": "def main(script, filename='158-0.txt', n=100, order=2):\n    try:\n        n = int(n)\n        order = int(order)\n    except ValueError:\n        print('Usage: %d filename [# of words] [prefix length]' % script)\n    else: \n        markov = Markov()\n        markov.process_file(filename, order)\n        markov.random_text(n)",
        "detail": "code.markov2",
        "documentation": {}
    },
    {
        "label": "metathesis_pairs",
        "kind": 2,
        "importPath": "code.metathesis",
        "description": "code.metathesis",
        "peekOfCode": "def metathesis_pairs(d):\n    \"\"\"Print all pairs of words that differ by swapping two letters.\n    d: map from word to list of anagrams\n    \"\"\"\n    for anagrams in d.values():\n        for word1 in anagrams:\n            for word2 in anagrams:\n                if word1 < word2 and word_distance(word1, word2) == 2:\n                    print(word1, word2)\ndef word_distance(word1, word2):",
        "detail": "code.metathesis",
        "documentation": {}
    },
    {
        "label": "word_distance",
        "kind": 2,
        "importPath": "code.metathesis",
        "description": "code.metathesis",
        "peekOfCode": "def word_distance(word1, word2):\n    \"\"\"Computes the number of differences between two words.\n    word1, word2: strings\n    Returns: integer\n    \"\"\"\n    assert len(word1) == len(word2)\n    count = 0\n    for c1, c2 in zip(word1, word2):\n        if c1 != c2:\n            count += 1",
        "detail": "code.metathesis",
        "documentation": {}
    },
    {
        "label": "most_frequent",
        "kind": 2,
        "importPath": "code.most_frequent",
        "description": "code.most_frequent",
        "peekOfCode": "def most_frequent(s):\n    \"\"\"Sorts the letters in s in reverse order of frequency.\n    s: string\n    Returns: list of letters\n    \"\"\"\n    hist = make_histogram(s)\n    t = []\n    for x, freq in hist.items():\n        t.append((freq, x))\n    t.sort(reverse=True)",
        "detail": "code.most_frequent",
        "documentation": {}
    },
    {
        "label": "make_histogram",
        "kind": 2,
        "importPath": "code.most_frequent",
        "description": "code.most_frequent",
        "peekOfCode": "def make_histogram(s):\n    \"\"\"Make a map from letters to number of times they appear in s.\n    s: string\n    Returns: map from letter to frequency\n    \"\"\"\n    hist = {}\n    for x in s:\n        hist[x] = hist.get(x, 0) + 1\n    return hist\ndef read_file(filename):",
        "detail": "code.most_frequent",
        "documentation": {}
    },
    {
        "label": "read_file",
        "kind": 2,
        "importPath": "code.most_frequent",
        "description": "code.most_frequent",
        "peekOfCode": "def read_file(filename):\n    \"\"\"Returns the contents of a file as a string.\"\"\"\n    return open(filename).read()\nif __name__ == '__main__':\n    string = read_file('/Users/dengwentao/work/python_project/ThinkPython2-CN/code/emma.txt')\n    letter_seq = most_frequent(string)\n    for x in letter_seq:\n        print(x)",
        "detail": "code.most_frequent",
        "documentation": {}
    },
    {
        "label": "arc",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def arc(t, r, angle):\n    \"\"\"绘制一个近似的圆\n    t: turtle 小乌龟进程\n    r: 半径\n    \"\"\"\n    # polygon里的长度和边数都是根据r来计算的，所以获取的值会传递给它\n    # 圆的周长可以通过公式 L=2πr, 其中L是圆的周长，r是圆的半径，π是一个常数，可以用math.pi来获取\n    # 如果r=5，那么周长L是多少？\n    # 如果边数n设置为6 那么长度是多少？\n    n = 100",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def circle(t, r):\n    circumference = 2* math.pi * r\n    n = 50\n    length = circumference / n\n    polygon(t, n=n, length=length)\n# 函数接口是函数用途的摘要：参数是什么？函数做什么？返回什么？如果一个接口允许调用者执行所需操作，\n# 而无需处理无关的细节，那么这个接口就是简洁的。\n# 与其将n作为参数传入令接口复杂，不如根据周长来确定一个合适的 n：\ndef circle(t, r):\n    circumference = 2 * math.pi * r",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def circle(t, r):\n    circumference = 2 * math.pi * r\n    n = int(circumference / 3) + 3\n    length = circumference / n\n    polygon(t, n, length)\n# circle(bob, 50)\n# 4.7 重构\ndef polyline(t, n, length, angle):\n    for i in range(n):\n        t.fd(length)",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "polyline",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def polyline(t, n, length, angle):\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle)\ndef polygon(t, n ,length):\n    angle = 360.0 / n\n    polyline(t, length, angle)\ndef arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1    ",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "polygon",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def polygon(t, n ,length):\n    angle = 360.0 / n\n    polyline(t, length, angle)\ndef arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1    \n    step_length = arc_length / n\n    step_angle = float(angle) / n\n    polyline(t, n, step_length, step_angle)\ndef circle(t, r):",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "arc",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def arc(t, r, angle):\n    arc_length = 2 * math.pi * r * angle / 360\n    n = int(arc_length / 3) + 1    \n    step_length = arc_length / n\n    step_angle = float(angle) / n\n    polyline(t, n, step_length, step_angle)\ndef circle(t, r):\n    arc(t, r, 360)\ncircle(bob, 50)    \n# 此过程---调整代码，优化接口，便于复用---叫做重构。",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 2,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "def circle(t, r):\n    arc(t, r, 360)\ncircle(bob, 50)    \n# 此过程---调整代码，优化接口，便于复用---叫做重构。\n# 此案例中，我们发现 arc 和 polygon 具有一些相似代码，所以将其“抽离”为polyline。\n# 如果早有规划，我们可能会优先编写 polyline，避免后续耗时重构，但一般你很难在项目开始的时候，\n# 便深入了解一切，规划好所有接口。只有开始编码，你才会更好地研究并理解其中曲折。\n# 所以，有时候重构便是你学到了一些东西的标志。\n# 4.8 开发计划\n# 尽量复制粘贴，减少打字（以及重复调试）",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.mypolygon",
        "description": "code.mypolygon",
        "peekOfCode": "bob = turtle.Turtle()\nprint(bob)\n# bob.fd(100)\n# bob.lt(90)\n# bob.fd(100)\n# for i in range(4):\n#     bob.fd(100)\n#     bob.lt(90)\n# turtle.mainloop()\n# tuetle模块提供了函数 Turtle，可以用来创建 Tuttle 对象，我们将其分配给名为 bob 的变量。",
        "detail": "code.mypolygon",
        "documentation": {}
    },
    {
        "label": "minutes",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "minutes = 43.5\nhours = minutes / 60\nkm_per_mile = 1.61\nkm = 10\nmiles = km / km_per_mile \npace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "hours",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "hours = minutes / 60\nkm_per_mile = 1.61\nkm = 10\nmiles = km / km_per_mile \npace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "km_per_mile",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "km_per_mile = 1.61\nkm = 10\nmiles = km / km_per_mile \npace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "km",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "km = 10\nmiles = km / km_per_mile \npace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "miles",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "miles = km / km_per_mile \npace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "pace",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "pace = minutes / miles\nmph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "mph",
        "kind": 5,
        "importPath": "code.pace_calc",
        "description": "code.pace_calc",
        "peekOfCode": "mph = miles / hours\nprint('Pace in minutes per mile:', pace)\nprint('Average speed in mph:', mph)",
        "detail": "code.pace_calc",
        "documentation": {}
    },
    {
        "label": "first",
        "kind": 2,
        "importPath": "code.palindrome_soln",
        "description": "code.palindrome_soln",
        "peekOfCode": "def first(word):\n    \"\"\"Returns the first character of a string.\"\"\"\n    return word[0]\ndef last(word):\n    \"\"\"Returns the last of a string.\"\"\"\n    return word[-1]\ndef middle(word):\n    \"\"\"Returns all but the first and last characters of a string.\"\"\"\n    return word[1:-1]\ndef is_palindrome(word):",
        "detail": "code.palindrome_soln",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 2,
        "importPath": "code.palindrome_soln",
        "description": "code.palindrome_soln",
        "peekOfCode": "def last(word):\n    \"\"\"Returns the last of a string.\"\"\"\n    return word[-1]\ndef middle(word):\n    \"\"\"Returns all but the first and last characters of a string.\"\"\"\n    return word[1:-1]\ndef is_palindrome(word):\n    \"\"\"Returns True if word is a palindrome.\"\"\"\n    if len(word) <= 1:\n        return True",
        "detail": "code.palindrome_soln",
        "documentation": {}
    },
    {
        "label": "middle",
        "kind": 2,
        "importPath": "code.palindrome_soln",
        "description": "code.palindrome_soln",
        "peekOfCode": "def middle(word):\n    \"\"\"Returns all but the first and last characters of a string.\"\"\"\n    return word[1:-1]\ndef is_palindrome(word):\n    \"\"\"Returns True if word is a palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    if first(word) != last(word):\n        return False\n    return is_palindrome(middle(word))",
        "detail": "code.palindrome_soln",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "code.palindrome_soln",
        "description": "code.palindrome_soln",
        "peekOfCode": "def is_palindrome(word):\n    \"\"\"Returns True if word is a palindrome.\"\"\"\n    if len(word) <= 1:\n        return True\n    if first(word) != last(word):\n        return False\n    return is_palindrome(middle(word))\nprint(is_palindrome('allen'))\nprint(is_palindrome('bob'))\nprint(is_palindrome('otto'))",
        "detail": "code.palindrome_soln",
        "documentation": {}
    },
    {
        "label": "factorial",
        "kind": 2,
        "importPath": "code.pi",
        "description": "code.pi",
        "peekOfCode": "def factorial(n):\n    \"\"\"Computes factorial of n recursively.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        recurse = factorial(n-1)\n        result = n * recurse\n        return result\ndef estimate_pi():\n    \"\"\"Computes an estimate of pi.",
        "detail": "code.pi",
        "documentation": {}
    },
    {
        "label": "estimate_pi",
        "kind": 2,
        "importPath": "code.pi",
        "description": "code.pi",
        "peekOfCode": "def estimate_pi():\n    \"\"\"Computes an estimate of pi.\n    Algorithm due to Srinivasa Ramanujan, from \n    http://en.wikipedia.org/wiki/Pi\n    \"\"\"\n    total = 0\n    k = 0\n    factor = 2 * math.sqrt(2) / 9801\n    while True:\n        num = factorial(4*k) * (1103 + 26390*k)",
        "detail": "code.pi",
        "documentation": {}
    },
    {
        "label": "draw_pie",
        "kind": 2,
        "importPath": "code.pie",
        "description": "code.pie",
        "peekOfCode": "def draw_pie(t, n, r):\n    \"\"\"Draws a pie, then moves into position to the right.\n    t: Turtle\n    n: number of segments\n    r: length of the radial spokes\n    \"\"\"\n    polypie(t, n, r)\n    t.pu()\n    t.fd(r*2 + 10)\n    t.pd()",
        "detail": "code.pie",
        "documentation": {}
    },
    {
        "label": "polypie",
        "kind": 2,
        "importPath": "code.pie",
        "description": "code.pie",
        "peekOfCode": "def polypie(t, n, r):\n    \"\"\"Draws a pie divided into radial segments.\n    t: Turtle\n    n: number of segments\n    r: length of the radial spokes\n    \"\"\"\n    angle = 360.0 / n\n    for i in range(n):\n        isosceles(t, r, angle/2)\n        t.lt(angle)",
        "detail": "code.pie",
        "documentation": {}
    },
    {
        "label": "isosceles",
        "kind": 2,
        "importPath": "code.pie",
        "description": "code.pie",
        "peekOfCode": "def isosceles(t, r, angle):\n    \"\"\"Draws an icosceles triangle.\n    The turtle starts and ends at the peak, facing the middle of the base.\n    t: Turtle\n    r: length of the equal legs\n    angle: half peak angle in degrees\n    \"\"\"\n    y = r * math.sin(angle * math.pi / 180)\n    t.rt(angle)\n    t.fd(r)",
        "detail": "code.pie",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.pie",
        "description": "code.pie",
        "peekOfCode": "bob = turtle.Turtle()\nbob.pu()\nbob.bk(130)\nbob.pd()\n# draw polypies with various number of sides\nsize = 40\ndraw_pie(bob, 5, size)\ndraw_pie(bob, 6, size)\ndraw_pie(bob, 7, size)\ndraw_pie(bob, 8, size)",
        "detail": "code.pie",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "code.pie",
        "description": "code.pie",
        "peekOfCode": "size = 40\ndraw_pie(bob, 5, size)\ndraw_pie(bob, 6, size)\ndraw_pie(bob, 7, size)\ndraw_pie(bob, 8, size)\nbob.hideturtle()\nturtle.mainloop()",
        "detail": "code.pie",
        "documentation": {}
    },
    {
        "label": "square",
        "kind": 2,
        "importPath": "code.polygon",
        "description": "code.polygon",
        "peekOfCode": "def square(t, length):\n    \"\"\"Draws a square with sides of the given length.\n    Returns the Turtle to the starting position and location.\n    \"\"\"\n    for i in range(4):\n        t.fd(length)\n        t.lt(90)\ndef polyline(t, n, length, angle):\n    \"\"\"Draws n line segments.\n    t: Turtle object",
        "detail": "code.polygon",
        "documentation": {}
    },
    {
        "label": "polyline",
        "kind": 2,
        "importPath": "code.polygon",
        "description": "code.polygon",
        "peekOfCode": "def polyline(t, n, length, angle):\n    \"\"\"Draws n line segments.\n    t: Turtle object\n    n: number of line segments\n    length: length of each segment\n    angle: degrees between segments\n    \"\"\"\n    for i in range(n):\n        t.fd(length)\n        t.lt(angle)",
        "detail": "code.polygon",
        "documentation": {}
    },
    {
        "label": "polygon",
        "kind": 2,
        "importPath": "code.polygon",
        "description": "code.polygon",
        "peekOfCode": "def polygon(t, n, length):\n    \"\"\"Draws a polygon with n sides.\n    t: Turtle\n    n: number of sides\n    length: length of each side.\n    \"\"\"\n    angle = 360.0/n\n    polyline(t, n, length, angle)\ndef arc(t, r, angle):\n    \"\"\"Draws an arc with the given radius and angle.",
        "detail": "code.polygon",
        "documentation": {}
    },
    {
        "label": "arc",
        "kind": 2,
        "importPath": "code.polygon",
        "description": "code.polygon",
        "peekOfCode": "def arc(t, r, angle):\n    \"\"\"Draws an arc with the given radius and angle.\n    t: Turtle\n    r: radius\n    angle: angle subtended by the arc, in degrees\n    \"\"\"\n    arc_length = 2 * math.pi * r * abs(angle) / 360\n    n = int(arc_length / 4) + 3\n    step_length = arc_length / n\n    step_angle = float(angle) / n",
        "detail": "code.polygon",
        "documentation": {}
    },
    {
        "label": "circle",
        "kind": 2,
        "importPath": "code.polygon",
        "description": "code.polygon",
        "peekOfCode": "def circle(t, r):\n    \"\"\"Draws a circle with the given radius.\n    t: Turtle\n    r: radius\n    \"\"\"\n    arc(t, r, 360)\n# the following condition checks whether we are\n# running as a script, in which case run the test code,\n# or being imported, in which case don't.\nif __name__ == '__main__':",
        "detail": "code.polygon",
        "documentation": {}
    },
    {
        "label": "read_dictionary",
        "kind": 2,
        "importPath": "code.pronounce",
        "description": "code.pronounce",
        "peekOfCode": "def read_dictionary(filename='c06d'):\n    \"\"\"Reads from a file and builds a dictionary that maps from\n    each word to a string that describes its primary pronunciation.\n    Secondary pronunciations are added to the dictionary with\n    a number, in parentheses, at the end of the key, so the\n    key for the second pronunciation of \"abdominal\" is \"abdominal(2)\".\n    filename: string\n    returns: map from string to pronunciation\n    \"\"\"\n    d = dict()",
        "detail": "code.pronounce",
        "documentation": {}
    },
    {
        "label": "make_word_dict",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def make_word_dict():\n    \"\"\"Reads a word list and returns a dictionary.\"\"\"\n    d = dict()\n    fin = open('words.txt')\n    for line in fin:\n        word = line.strip().lower()\n        d[word] = None\n    # have to add single letter words to the word list;\n    # also, the empty string is considered a word.\n    for letter in ['a', 'i', '']:",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "is_reducible",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def is_reducible(word, word_dict):\n    \"\"\"If word is reducible, returns a list of its reducible children.\n    Also adds an entry to the memo dictionary.\n    A string is reducible if it has at least one child that is \n    reducible.  The empty string is also reducible.\n    word: string\n    word_dict: dictionary with words as keys\n    \"\"\"\n     # if have already checked this word, return the answer\n    if word in memo:",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "children",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def children(word, word_dict):\n    \"\"\"Returns a list of all words that can be formed by removing one letter.\n    word: string\n    Returns: list of strings\n    \"\"\"\n    res = []\n    for i in range(len(word)):\n        child = word[:i] + word[i+1:]\n        if child in word_dict:\n            res.append(child)",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "all_reducible",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def all_reducible(word_dict):\n    \"\"\"Checks all words in the word_dict; returns a list reducible ones.\n    word_dict: dictionary with words as keys\n    \"\"\"\n    res = []\n    for word in word_dict:\n        t = is_reducible(word, word_dict)\n        if t != []:\n            res.append(word)\n    return res",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "print_trail",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def print_trail(word):\n    \"\"\"Prints the sequence of words that reduces this word to the empty string.\n    If there is more than one choice, it chooses the first.\n    word: string\n    \"\"\"\n    if len(word) == 0:\n        return\n    print(word, end=' ')\n    t = is_reducible(word, word_dict)\n    print_trail(t[0])",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "print_longest_words",
        "kind": 2,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "def print_longest_words(word_dict):\n    \"\"\"Finds the longest reducible words and prints them.\n    word_dict: dictionary of valid words\n    \"\"\"\n    words = all_reducible(word_dict)\n    # use DSU to sort by word length\n    t = []\n    for word in words:\n        t.append((len(word), word))\n    t.sort(reverse=True)",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "memo",
        "kind": 5,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "memo = {}\nmemo[''] = ['']\ndef is_reducible(word, word_dict):\n    \"\"\"If word is reducible, returns a list of its reducible children.\n    Also adds an entry to the memo dictionary.\n    A string is reducible if it has at least one child that is \n    reducible.  The empty string is also reducible.\n    word: string\n    word_dict: dictionary with words as keys\n    \"\"\"",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "memo['']",
        "kind": 5,
        "importPath": "code.reducible",
        "description": "code.reducible",
        "peekOfCode": "memo[''] = ['']\ndef is_reducible(word, word_dict):\n    \"\"\"If word is reducible, returns a list of its reducible children.\n    Also adds an entry to the memo dictionary.\n    A string is reducible if it has at least one child that is \n    reducible.  The empty string is also reducible.\n    word: string\n    word_dict: dictionary with words as keys\n    \"\"\"\n     # if have already checked this word, return the answer",
        "detail": "code.reducible",
        "documentation": {}
    },
    {
        "label": "reverse_pair",
        "kind": 2,
        "importPath": "code.reverse_pair",
        "description": "code.reverse_pair",
        "peekOfCode": "def reverse_pair(word_list, word):\n    \"\"\"Checks whether a reversed word appears in word_list.\n    word_list: list of strings\n    word: string\n    \"\"\"\n    rev_word = word[::-1]\n    return in_bisect(word_list, rev_word)\nif __name__ == '__main__':\n    word_list = make_word_list()\n    for word in word_list:",
        "detail": "code.reverse_pair",
        "documentation": {}
    },
    {
        "label": "rotate_letter",
        "kind": 2,
        "importPath": "code.rotate",
        "description": "code.rotate",
        "peekOfCode": "def rotate_letter(letter, n):\n    \"\"\"Rotates a letter by n places.  Does not change other chars.\n    letter: single-letter string\n    n: int\n    Returns: single-letter string\n    \"\"\"\n    if letter.isupper():\n        start = ord('A')\n    elif letter.islower():\n        start = ord('a')",
        "detail": "code.rotate",
        "documentation": {}
    },
    {
        "label": "rotate_word",
        "kind": 2,
        "importPath": "code.rotate",
        "description": "code.rotate",
        "peekOfCode": "def rotate_word(word, n):\n    \"\"\"Rotates a word by n places.\n    word: string\n    n: integer\n    Returns: string\n    \"\"\"\n    res = ''\n    for letter in word:\n        res += rotate_letter(letter, n)\n    return res",
        "detail": "code.rotate",
        "documentation": {}
    },
    {
        "label": "make_word_dict",
        "kind": 2,
        "importPath": "code.rotate_pairs",
        "description": "code.rotate_pairs",
        "peekOfCode": "def make_word_dict():\n    \"\"\"Read the words in words.txt and return a dictionary\n    that contains the words as keys\"\"\"\n    d = dict()\n    fin = open('words.txt')\n    for line in fin:\n        word = line.strip().lower()\n        d[word] = None\n    return d\ndef rotate_pairs(word, word_dict):",
        "detail": "code.rotate_pairs",
        "documentation": {}
    },
    {
        "label": "rotate_pairs",
        "kind": 2,
        "importPath": "code.rotate_pairs",
        "description": "code.rotate_pairs",
        "peekOfCode": "def rotate_pairs(word, word_dict):\n    \"\"\"Prints all words that can be generated by rotating word.\n    word: string\n    word_dict: dictionary with words as keys\n    \"\"\"\n    for i in range(1, 14):\n        rotated = rotate_word(word, i)\n        if rotated in word_dict:\n            print(word, i, rotated)\nif __name__ == '__main__':",
        "detail": "code.rotate_pairs",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "code.run_all_solutions",
        "description": "code.run_all_solutions",
        "peekOfCode": "def pipe(cmd):\n    \"\"\"Runs a command in a subprocess.\n    cmd: string Unix command\n    Returns (res, stat), the output of the subprocess and the exit status.\n    \"\"\"\n    # Note: os.popen is deprecated\n    # now, which means we are supposed to stop using it and start using\n    # the subprocess module.  But for simple cases, I find\n    # subprocess more complicated than necessary.  So I am going\n    # to keep using os.popen until they take it away.",
        "detail": "code.run_all_solutions",
        "documentation": {}
    },
    {
        "label": "filenames",
        "kind": 5,
        "importPath": "code.run_all_solutions",
        "description": "code.run_all_solutions",
        "peekOfCode": "filenames = \"\"\"\nackermann_memo.py        grid.py             PokerHand.py\nackermann.py             has_duplicates.py   PokerHandSoln.py\nanagram_db.py            header.py           polygon.py\nanagram_sets.py          inlist.py           reducible.py\nanalyze_book1.py         interlock.py        reverse_pair.py\nanalyze_book2.py         invert_dict.py      rotate_pairs.py\nanalyze_book3.py         koch.py             rotate.py\nBadKangaroo.py           letters.py          sed.py\nbirthday.py              Map.py              spiral.py",
        "detail": "code.run_all_solutions",
        "documentation": {}
    },
    {
        "label": "slow_ones",
        "kind": 5,
        "importPath": "code.run_all_solutions",
        "description": "code.run_all_solutions",
        "peekOfCode": "slow_ones = \"\"\"\nspiral.py                typewriter.py       pie.py\nflower.py                wordlist.py         polygon.py\nkoch.py                  letters.py          zipf.py\n\"\"\".split()\nfor filename in filenames.split():\n    print(filename)\n    if filename in slow_ones:\n        print('Skipping')\n        continue",
        "detail": "code.run_all_solutions",
        "documentation": {}
    },
    {
        "label": "sed",
        "kind": 2,
        "importPath": "code.sed",
        "description": "code.sed",
        "peekOfCode": "def sed(pattern, replace, source, dest):\n    \"\"\"Reads a source file and writes the destination file.\n    In each line, replaces pattern with replace.\n    pattern: string\n    replace: string\n    source: string filename\n    dest: string filename\n    \"\"\"\n    fin = open(source, 'r')\n    fout = open(dest, 'w')",
        "detail": "code.sed",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.sed",
        "description": "code.sed",
        "peekOfCode": "def main():\n    pattern = 'pattern'\n    replace = 'replace'\n    source = 'sed_tester.txt'\n    dest = source + '.replaced'\n    sed(pattern, replace, source, dest)\nif __name__ == '__main__':\n    main()",
        "detail": "code.sed",
        "documentation": {}
    },
    {
        "label": "draw_spiral",
        "kind": 2,
        "importPath": "code.spiral",
        "description": "code.spiral",
        "peekOfCode": "def draw_spiral(t, n, length=3, a=0.1, b=0.0002):\n    \"\"\"Draws an Archimedian spiral starting at the origin.\n    Args:\n      n: how many line segments to draw\n      length: how long each segment is\n      a: how loose the initial spiral starts out (larger is looser)\n      b: how loosly coiled the spiral is (larger is looser)\n    http://en.wikipedia.org/wiki/Spiral\n    \"\"\"\n    theta = 0.0",
        "detail": "code.spiral",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.spiral",
        "description": "code.spiral",
        "peekOfCode": "bob = turtle.Turtle()\ndraw_spiral(bob, n=1000)\nturtle.mainloop()",
        "detail": "code.spiral",
        "documentation": {}
    },
    {
        "label": "structshape",
        "kind": 2,
        "importPath": "code.structshape",
        "description": "code.structshape",
        "peekOfCode": "def structshape(ds):\n    \"\"\"Returns a string that describes the shape of a data structure.\n    ds: any Python object\n    Returns: string\n    \"\"\"\n    typename = type(ds).__name__\n    # handle sequences\n    sequence = (list, tuple, set, type(iter('')))\n    if isinstance(ds, sequence):\n        t = []",
        "detail": "code.structshape",
        "documentation": {}
    },
    {
        "label": "listrep",
        "kind": 2,
        "importPath": "code.structshape",
        "description": "code.structshape",
        "peekOfCode": "def listrep(t):\n    \"\"\"Returns a string representation of a list of type strings.\n    t: list of strings\n    Returns: string\n    \"\"\"\n    current = t[0]\n    count = 0\n    res = []\n    for x in t:\n        if x == current:",
        "detail": "code.structshape",
        "documentation": {}
    },
    {
        "label": "setrep",
        "kind": 2,
        "importPath": "code.structshape",
        "description": "code.structshape",
        "peekOfCode": "def setrep(s):\n    \"\"\"Returns a string representation of a set of type strings.\n    s: set of strings\n    Returns: string\n    \"\"\"\n    rep = ', '.join(s)\n    if len(s) == 1:\n        return rep\n    else:\n        return '(' + rep + ')'",
        "detail": "code.structshape",
        "documentation": {}
    },
    {
        "label": "append",
        "kind": 2,
        "importPath": "code.structshape",
        "description": "code.structshape",
        "peekOfCode": "def append(res, typestr, count):\n    \"\"\"Adds a new element to a list of type strings.\n    Modifies res.\n    res: list of type strings\n    typestr: the new type string\n    count: how many of the new type there are\n    Returns: None\n    \"\"\"\n    if count == 1:\n        rep = typestr",
        "detail": "code.structshape",
        "documentation": {}
    },
    {
        "label": "teleport",
        "kind": 2,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "def teleport(t, x, y):\n    \"\"\"Moves the turtle without drawing a line.\n    Postcondition: pen is down\n    t: Turtle\n    x: coordinate\n    y: coordinate\n    \"\"\"\n    t.pu()\n    t.goto(x, y)\n    t.pd()",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "keypress",
        "kind": 2,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "def keypress(char):\n    \"\"\"Handles the event when a user presses a key.\n    Checks if there is a function with the right name; otherwise\n    it prints an error message.\n    char: string, letter to draw\n    \"\"\"\n    # if we're still drawing the previous letter, bail out\n    if bob.busy:\n        return\n    else:",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "carriage_return",
        "kind": 2,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "def carriage_return():\n    \"\"\"Moves to the beginning of the next line.\n    \"\"\"\n    teleport(bob, -180, bob.ycor() - size*3)\n    bob.busy = False\ndef presser(char):\n    \"\"\"Returns a function object that executes keypress.\n    char: character to draw when the function is executed\n    returns: function with no arguments\n    \"\"\"",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "presser",
        "kind": 2,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "def presser(char):\n    \"\"\"Returns a function object that executes keypress.\n    char: character to draw when the function is executed\n    returns: function with no arguments\n    \"\"\"\n    def func():\n        keypress(char)\n    return func\n# create and position the turtle\nsize = 20",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "size = 20\nbob = turtle.Turtle()\nbob.busy = False\nteleport(bob, -180, 150)\n# tell world to call keypress when the user presses a key\nscreen = bob.getscreen()\nfor char in string.ascii_lowercase:\n    screen.onkey(presser(char), char)\nscreen.onkey(carriage_return, 'Return')\nscreen.listen()",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "bob",
        "kind": 5,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "bob = turtle.Turtle()\nbob.busy = False\nteleport(bob, -180, 150)\n# tell world to call keypress when the user presses a key\nscreen = bob.getscreen()\nfor char in string.ascii_lowercase:\n    screen.onkey(presser(char), char)\nscreen.onkey(carriage_return, 'Return')\nscreen.listen()\nturtle.mainloop()",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "bob.busy",
        "kind": 5,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "bob.busy = False\nteleport(bob, -180, 150)\n# tell world to call keypress when the user presses a key\nscreen = bob.getscreen()\nfor char in string.ascii_lowercase:\n    screen.onkey(presser(char), char)\nscreen.onkey(carriage_return, 'Return')\nscreen.listen()\nturtle.mainloop()",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "code.typewriter",
        "description": "code.typewriter",
        "peekOfCode": "screen = bob.getscreen()\nfor char in string.ascii_lowercase:\n    screen.onkey(presser(char), char)\nscreen.onkey(carriage_return, 'Return')\nscreen.listen()\nturtle.mainloop()",
        "detail": "code.typewriter",
        "documentation": {}
    },
    {
        "label": "sort_by_length",
        "kind": 2,
        "importPath": "code.unstable_sort",
        "description": "code.unstable_sort",
        "peekOfCode": "def sort_by_length(words):\n    \"\"\"Sort a list of words in reverse order by length.\n    This is the version in the book; it is stable in the sense that\n    words with the same length appear in the same order\n    words: list of strings\n    Returns: list of strings\n    \"\"\"\n    t = []\n    for word in words:\n        t.append((len(word), word))",
        "detail": "code.unstable_sort",
        "documentation": {}
    },
    {
        "label": "sort_by_length_random",
        "kind": 2,
        "importPath": "code.unstable_sort",
        "description": "code.unstable_sort",
        "peekOfCode": "def sort_by_length_random(words):\n    \"\"\"Sort a list of words in reverse order by length.\n    This is the solution to the exercise.  It is unstable in the\n    sense that if two words have the same length, their order in\n    the output list is random.\n    It works by extending the list of tuples with a column of\n    random numbers; when there is a tie in the first column,\n    the random column determines the output order.\n    words: list of strings\n    Returns: list of strings",
        "detail": "code.unstable_sort",
        "documentation": {}
    },
    {
        "label": "walk",
        "kind": 2,
        "importPath": "code.walk",
        "description": "code.walk",
        "peekOfCode": "def walk(dirname):\n    \"\"\"Prints the names of all files in dirname and its subdirectories.\n    This is the version in the book.\n    dirname: string name of directory\n    \"\"\"\n    for name in os.listdir(dirname):\n        path = os.path.join(dirname, name)\n        if os.path.isfile(path):\n            print(path)\n        else:",
        "detail": "code.walk",
        "documentation": {}
    },
    {
        "label": "walk2",
        "kind": 2,
        "importPath": "code.walk",
        "description": "code.walk",
        "peekOfCode": "def walk2(dirname):\n    \"\"\"Prints the names of all files in dirname and its subdirectories.\n    This is the exercise solution, which uses os.walk.\n    dirname: string name of directory\n    \"\"\"\n    for root, dirs, files in os.walk(dirname):\n        for filename in files:\n            print(os.path.join(root, filename))\nif __name__ == '__main__':\n    walk('.')",
        "detail": "code.walk",
        "documentation": {}
    },
    {
        "label": "linecount",
        "kind": 2,
        "importPath": "code.wc",
        "description": "code.wc",
        "peekOfCode": "def linecount(filename):\n    count = 0\n    for line in filename:\n        count += 1\n    return count\n# 通常，当你导入一个模块，只应定义新的函数，而不应该执行它们。\n# 如果需要将程序作为模块导入，通常遵循下面的写法：\nif __name__ == '__main__':  \n    print(linecount('wc.py'))\n# __name__是一个内置变量，程序运行便被赋值，当作脚本运行时就是 '__main__'。",
        "detail": "code.wc",
        "documentation": {}
    },
    {
        "label": "make_word_list1",
        "kind": 2,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "def make_word_list1():\n    \"\"\"Reads lines from a file and builds a list using append.\"\"\"\n    t = []\n    fin = open('./words.txt')\n    for line in fin:\n        word = line.strip()\n        t.append(word)\n    return t\ndef make_word_list2():\n    \"\"\"Reads lines from a file and builds a list using list +.\"\"\"",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "make_word_list2",
        "kind": 2,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "def make_word_list2():\n    \"\"\"Reads lines from a file and builds a list using list +.\"\"\"\n    t = []\n    fin = open('./words.txt')\n    for line in fin:\n        word = line.strip()\n        t = t + [word]\n    return t\nstart_time = time.time()\nt = make_word_list1()",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "start_time = time.time()\nt = make_word_list1()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')\nstart_time = time.time()\nt = make_word_list2()\nelapsed_time = time.time() - start_time\nprint(len(t))",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "t = make_word_list1()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')\nstart_time = time.time()\nt = make_word_list2()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "elapsed_time",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "elapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')\nstart_time = time.time()\nt = make_word_list2()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "start_time = time.time()\nt = make_word_list2()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "t = make_word_list2()\nelapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "elapsed_time",
        "kind": 5,
        "importPath": "code.wordlist",
        "description": "code.wordlist",
        "peekOfCode": "elapsed_time = time.time() - start_time\nprint(len(t))\nprint(t[:10])\nprint(elapsed_time, 'seconds')",
        "detail": "code.wordlist",
        "documentation": {}
    },
    {
        "label": "rank_freq",
        "kind": 2,
        "importPath": "code.zipf",
        "description": "code.zipf",
        "peekOfCode": "def rank_freq(hist):\n    \"\"\"Returns a list of (rank, freq) tuples.\n    hist: map from word to frequency\n    returns: list of (rank, freq) tuples\n    \"\"\"\n    # sort the list of frequencies in decreasing order\n    freqs = list(hist.values())\n    freqs.sort(reverse=True)\n    # enumerate the ranks and frequencies \n    rf = [(r+1, f) for r, f in enumerate(freqs)]",
        "detail": "code.zipf",
        "documentation": {}
    },
    {
        "label": "print_ranks",
        "kind": 2,
        "importPath": "code.zipf",
        "description": "code.zipf",
        "peekOfCode": "def print_ranks(hist):\n    \"\"\"Prints the rank vs. frequency data.\n    hist: map from word to frequency\n    \"\"\"\n    for r, f in rank_freq(hist):\n        print(r, f)\ndef plot_ranks(hist, scale='log'):\n    \"\"\"Plots frequency vs. rank.\n    hist: map from word to frequency\n    scale: string 'linear' or 'log'",
        "detail": "code.zipf",
        "documentation": {}
    },
    {
        "label": "plot_ranks",
        "kind": 2,
        "importPath": "code.zipf",
        "description": "code.zipf",
        "peekOfCode": "def plot_ranks(hist, scale='log'):\n    \"\"\"Plots frequency vs. rank.\n    hist: map from word to frequency\n    scale: string 'linear' or 'log'\n    \"\"\"\n    t = rank_freq(hist)\n    rs, fs = zip(*t)\n    plt.clf()\n    plt.xscale(scale)\n    plt.yscale(scale)",
        "detail": "code.zipf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "code.zipf",
        "description": "code.zipf",
        "peekOfCode": "def main(script, filename='emma.txt', flag='plot'):\n    hist = process_file(filename, skip_header=True)\n    # either print the results or plot them\n    if flag == 'print':\n        print_ranks(hist)\n    elif flag == 'plot':\n        plot_ranks(hist)\n    else:\n        print('Usage: zipf.py filename [print|plot]')\nif __name__ == '__main__':",
        "detail": "code.zipf",
        "documentation": {}
    },
    {
        "label": "FrameError",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class FrameError(ValueError):\n    \"\"\"Represents a problem with frame of reference.\"\"\"\nclass Vector:\n    def __init__(self, array, frame=None):\n        \"\"\"A vector is an array of coordinates and a frame of reference.\n        array: \n        frame: Frame object\n        \"\"\"\n        self.array = array\n        self.frame = frame",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "Vector",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class Vector:\n    def __init__(self, array, frame=None):\n        \"\"\"A vector is an array of coordinates and a frame of reference.\n        array: \n        frame: Frame object\n        \"\"\"\n        self.array = array\n        self.frame = frame\n    def __str__(self):\n        if self.frame == None:",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "Rotation",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class Rotation:\n    def __init__(self, array):\n        self.array = array\n    def __str__(self):\n        return 'Rotation\\n%s' % str(self.array)\n    def __neg__(self):\n        return Rotation(-self.array)\n    def __mul__(self, other):\n        \"\"\"Apply the rotation to a Vector.\"\"\"\n        return numpy.dot(self.array, other.array)",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "Transform",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class Transform:\n    \"\"\"Represents a transform from one Frame to another.\"\"\"\n    def __init__(self, rot, org, source=None):\n        \"\"\"Instantiates a Transform.\n        rot: Rotation object\n        org: origin Vector\n        source: source Frame\n        \"\"\"\n        self.rot = rot\n        self.org = org",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "Frame",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class Frame:\n    \"\"\"Represents a frame of reference.\"\"\"\n    # list of Frames\n    roster = []\n    def __init__(self, name):\n        \"\"\"Instantiate a Frame.\n        name: string\n        \"\"\"\n        self.name = name\n        self.transforms = {}",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "class Vertex:\n    \"\"\"Represents a node in a graph.\"\"\"\n    def __init__(self, frame):\n        self.frame = frame\n        self.dist = 1000000\n        self.out = []\n    def __str__(self):\n        return '%s %d' % (self.frame.name, self.dist)\ndef shortest_path(start, frames):\n    \"\"\"For a given list of frames and a starting frame,",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "println",
        "kind": 2,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "def println(s):\n    print(s, '\\n')\nclass FrameError(ValueError):\n    \"\"\"Represents a problem with frame of reference.\"\"\"\nclass Vector:\n    def __init__(self, array, frame=None):\n        \"\"\"A vector is an array of coordinates and a frame of reference.\n        array: \n        frame: Frame object\n        \"\"\"",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "shortest_path",
        "kind": 2,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "def shortest_path(start, frames):\n    \"\"\"For a given list of frames and a starting frame,\n    find the shortest path of transforms from the\n    starting frame to all other frames.\n    The 'distance' is the number of inverse transformations\n    that must be calculated.\n    The result is a dictionary of vertices, where\n    each vertex is labeled with the frame it corresponds\n    to, the distance from the starting frame, and the prev\n    frame along the path from start. \"\"\"",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "print_shortest_path",
        "kind": 2,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "def print_shortest_path(map):\n    for source, v in map.items():\n        try:\n            v.prev\n            print(source, v.dist, v.prev.frame)\n        except:\n            print(source, v.dist)\ndef print_length(length):\n    for v, w in length:\n        print(v.frame.name, w.frame.name, length[(v, w)])",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "print_length",
        "kind": 2,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "def print_length(length):\n    for v, w in length:\n        print(v.frame.name, w.frame.name, length[(v, w)])\n    print()\ndef main(name):\n    theta = math.pi/2\n    #v_o = Vector.from_list([0, 0, 0], None)\n    origin = Frame('O')\n    #o_trans = Transform(None, v_o, origin)\n    xhat = Vector.from_list([1, 0, 0], origin)",
        "detail": "python_thinking.Frame",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "python_thinking.Frame",
        "description": "python_thinking.Frame",
        "peekOfCode": "def main(name):\n    theta = math.pi/2\n    #v_o = Vector.from_list([0, 0, 0], None)\n    origin = Frame('O')\n    #o_trans = Transform(None, v_o, origin)\n    xhat = Vector.from_list([1, 0, 0], origin)\n    rx = Rotation.from_axis(xhat, theta)\n    a = Frame('A')\n    t_ao = Transform(rx, xhat, a)\n    yhat = Vector.from_list([0, 1, 0], a)",
        "detail": "python_thinking.Frame",
        "documentation": {}
    }
]